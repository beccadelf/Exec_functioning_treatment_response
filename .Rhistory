df[col, "Correlation"] <- round(correlation, 3)
df[col, "t_statistic"] <- round(t_statistic, 3)
df[col, "p_value"] <- round(p_value, 3)
}
return(df)
}
# Apply the correlation and significance test to your data
correlation_significance_table <- calculate_correlations_and_significance(df_basis = Patients_pre_vs_post_imp, cols = imp_columns)
#Helper function to avoid redundancy (Get pre and post data in one place for assumption and Welch test)
get_pre_post_data <- function(df_basis, col) {
pre_data <- df_basis[df_basis[["time"]] == "pre", col]
post_data <- df_basis[df_basis[["time"]] == "post", col]
return(list(pre = pre_data, post = post_data))
}
## Calculate Raw Pearson Correlation and Test Significance
calculate_correlations_and_significance <- function(df_basis, cols) {
df <- data.frame(Correlation = numeric(length(cols)), t_statistic = numeric(length(cols)),
p_value = numeric(length(cols)))
rownames(df) <- cols
for (col in cols) {
# Get pre and post data using the new function
data <- get_pre_post_data(df_basis, col)
pre_data <- data$pre
post_data <- data$post
# Calculate Pearson correlation
correlation <- cor(pre_data, post_data)
# Calculate the t-statistic for the correlation
n <- length(pre_data)
t_statistic <- correlation * sqrt((n - 2) / (1 - correlation^2))
# Calculate the p-value for a one-tailed test (H_0: r ≤ 0)
p_value <- pt(t_statistic, df = n - 2, lower.tail = FALSE)
# Store the results
df[col, "Correlation"] <- round(correlation, 3)
df[col, "t_statistic"] <- round(t_statistic, 3)
df[col, "p_value"] <- round(p_value, 3)
}
return(df)
}
# Apply the correlation and significance test to your data
correlation_significance_table <- calculate_correlations_and_significance(df_basis = Patients_pre_vs_post_imp, cols = imp_columns)
Patients_pre_vs_post_imp <- Patients_pre_vs_post_clean[,c("Subject",imp_columns,"time")]
View(Patients_pre_vs_post_imp)
## Calculate Raw Pearson Correlation and Test Significance
calculate_correlations_and_significance <- function(df_basis, cols) {
df <- data.frame(Correlation = numeric(length(cols)), t_statistic = numeric(length(cols)),
p_value = numeric(length(cols)))
rownames(df) <- cols
for (col in cols) {
# Get pre and post data using the new function
data <- get_pre_post_data(df_basis, col)
pre_data <- data$pre
post_data <- data$post
# Calculate Pearson correlation
correlation <- cor(pre_data, post_data)
# Calculate the t-statistic for the correlation
n <- length(pre_data)
t_statistic <- correlation * sqrt((n - 2) / (1 - correlation^2))
# Calculate the p-value for a one-tailed test (H_0: r ≤ 0)
p_value <- pt(t_statistic, df = n - 2, lower.tail = FALSE)
# Store the results
df[col, "Correlation"] <- round(correlation, 3)
df[col, "t_statistic"] <- round(t_statistic, 3)
df[col, "p_value"] <- round(p_value, 3)
}
return(df)
}
# Apply the correlation and significance test to your data
correlation_significance_table <- calculate_correlations_and_significance(df_basis = Patients_pre_vs_post_imp, cols = imp_columns)
pander(correlation_significance_table, style = "rmarkdown", fontsize = "tiny")
paired_t_test_mult_cols <- function(df_basis, cols) {
df <- data.frame(t_statistic = numeric(length(cols)), p_value = numeric(length(cols)),
group_mean_pre = numeric(length(cols)), group_mean_post = numeric(length(cols)),
cohen_d = numeric(length(cols)))
rownames(df) <- cols
for (col in cols) {
# Get pre and post data using get_pre_post_data helper function
data <- get_pre_post_data(df_basis, col)
pre_data <- na.omit(data$pre)
post_data <- na.omit(data$post)
# non-formula interface as before
results <- t.test(pre_data, post_data, paired = TRUE, var.equal = FALSE)
#Alternativ using formula method:
#results <- t.test(df_basis[[col]] ~ df_basis[["time"]], paired = TRUE, var.equal = FALSE)
# Calculate Cohen's d using the cohen.d function for paired samples (effect size)
cohen_d_result <- cohen.d(post_data, pre_data, paired = TRUE)
cohen_d <- cohen_d_result$estimate
# Calculate power using pwr.t.test
n <- length(pre_data)
power_result <- pwr.t.test(d = cohen_d, n = n, sig.level = 0.05, type = "paired", alternative = "greater")
#0.007? (Bonferroni)
power <- power_result$power
# Store the results
df[col, "t_statistic"] <- round(results$statistic, 2)
df[col, "p_value"] <- round(results$p.value, 2)
df[col, "group_mean_pre"] <- round(mean(pre_data), 2)
df[col, "sd_pre"] <- round(sd(pre_data), 2)
df[col, "group_mean_post"] <- round(mean(post_data), 2)
df[col, "sd_post"] <- round(sd(post_data), 2)
df[col, "cohen_d"] <- round(cohen_d, 2)
df[col, "power"] <- round(power, 2)
}
return(df)
}
t_test_table_pre_post <- paired_t_test_mult_cols(df_basis = Patients_pre_vs_post_imp, cols = BIS_columns_renamed)
paired_t_test_mult_cols <- function(df_basis, cols) {
df <- data.frame(t_statistic = numeric(length(cols)), p_value = numeric(length(cols)),
group_mean_pre = numeric(length(cols)), group_mean_post = numeric(length(cols)),
cohen_d = numeric(length(cols)))
rownames(df) <- cols
for (col in cols) {
# Get pre and post data using get_pre_post_data helper function
data <- get_pre_post_data(df_basis, col)
pre_data <- na.omit(data$pre)
post_data <- na.omit(data$post)
# non-formula interface as before
results <- t.test(pre_data, post_data, paired = TRUE, var.equal = FALSE)
#Alternativ using formula method:
#results <- t.test(df_basis[[col]] ~ df_basis[["time"]], paired = TRUE, var.equal = FALSE)
# Calculate Cohen's d using the cohen.d function for paired samples (effect size)
cohen_d_result <- cohen.d(post_data, pre_data, paired = TRUE)
cohen_d <- cohen_d_result$estimate
# Calculate power using pwr.t.test
n <- length(pre_data)
power_result <- pwr.t.test(d = cohen_d, n = n, sig.level = 0.05, type = "paired", alternative = "greater")
#0.007? (Bonferroni)
power <- power_result$power
# Store the results
df[col, "t_statistic"] <- round(results$statistic, 2)
df[col, "p_value"] <- round(results$p.value, 2)
df[col, "group_mean_pre"] <- round(mean(pre_data), 2)
df[col, "sd_pre"] <- round(sd(pre_data), 2)
df[col, "group_mean_post"] <- round(mean(post_data), 2)
df[col, "sd_post"] <- round(sd(post_data), 2)
df[col, "cohen_d"] <- round(cohen_d, 2)
df[col, "power"] <- round(power, 2)
}
return(df)
}
t_test_table_pre_post <- paired_t_test_mult_cols(df_basis = Patients_pre_vs_post_imp, cols = imp_columns)
test <- get_pre_post_data(Patients_pre_vs_post_imp, "SSRT")
complete_cases <- complete.cases(test$pre, test$post)
complete_cases
paired_t_test_mult_cols <- function(df_basis, cols) {
df <- data.frame(t_statistic = numeric(length(cols)), p_value = numeric(length(cols)),
group_mean_pre = numeric(length(cols)), group_mean_post = numeric(length(cols)),
cohen_d = numeric(length(cols)))
rownames(df) <- cols
for (col in cols) {
# Get pre and post data using get_pre_post_data helper function
data <- get_pre_post_data(df_basis, col)
# Use complete.cases to keep only rows where both pre and post are not NA
complete_cases <- complete.cases(data$pre, data$post)
pre_data <- data$pre[complete_cases]
post_data <- data$post[complete_cases]
# non-formula interface as before
results <- t.test(pre_data, post_data, paired = TRUE, var.equal = FALSE)
#Alternativ using formula method:
#results <- t.test(df_basis[[col]] ~ df_basis[["time"]], paired = TRUE, var.equal = FALSE)
# Calculate Cohen's d using the cohen.d function for paired samples (effect size)
cohen_d_result <- cohen.d(post_data, pre_data, paired = TRUE)
cohen_d <- cohen_d_result$estimate
# Calculate power using pwr.t.test
n <- length(pre_data)
power_result <- pwr.t.test(d = cohen_d, n = n, sig.level = 0.05, type = "paired", alternative = "greater")
#0.007? (Bonferroni)
power <- power_result$power
# Store the results
df[col, "t_statistic"] <- round(results$statistic, 2)
df[col, "p_value"] <- round(results$p.value, 2)
df[col, "group_mean_pre"] <- round(mean(pre_data), 2)
df[col, "sd_pre"] <- round(sd(pre_data), 2)
df[col, "group_mean_post"] <- round(mean(post_data), 2)
df[col, "sd_post"] <- round(sd(post_data), 2)
df[col, "cohen_d"] <- round(cohen_d, 2)
df[col, "power"] <- round(power, 2)
}
return(df)
}
t_test_table_pre_post <- paired_t_test_mult_cols(df_basis = Patients_pre_vs_post_imp, cols = imp_columns)
pander(t_test_table_pre_post)
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE,rows.print = 6, cols.min.print = 3)
library(haven)
library(rmatio)
library(DescTools)
library(data.table)
library(tidyverse)
library(caret)
library(SSRTcalc)
library(ggplot2)
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(dplyr)
library(tidyr)
library(pander)
library(effsize)
library(pwr)
library(gtsummary)
data_HC <- read.csv("Z:/Projekte_Meinke/Old_projects/Labrotation_Rebecca/Daten_Gruppenvergleich/With_wrong_responses/Data_HC.csv")
data_Pat_pre <- read.csv("Z:/Projekte_Meinke/Old_projects/Labrotation_Rebecca/Daten_Gruppenvergleich/With_wrong_responses/Data_Patients_Pre.csv")
data_Pat_post <- read.csv("Z:/Projekte_Meinke/Old_projects/Labrotation_Rebecca/Daten_Gruppenvergleich/With_wrong_responses/Data_Patients_Post.csv")
data_all <- haven::read_dta('Z:/Projekte_Meinke/Old_projects/Labrotation_Rebecca/CognitiveControl_Treatment/Data_Kevin_28.07.23.dta')
colnames(data_all)[which(colnames(data_all) == "id")] <- "Subject"
## 1. Merge patients pre and controls
Patients_vs_HC <- rbind(data_Pat_pre, data_HC)
## 2. Reduce dataset to BIS columns and SSRT
BIS_columns <- colnames(Patients_vs_HC)[grep("BIS", colnames(Patients_vs_HC))]
imp_columns <- c(BIS_columns, "SSRT")
Patients_vs_HC_imp <- Patients_vs_HC[,c("Subject","Gruppe",imp_columns)]
## 3. Add confounds (Alter, Geschlecht, Abschluss)
Patients_vs_HC_imp_conf <- merge(data_all[,c("Subject","Alter","Geschlecht","Abschluss")], Patients_vs_HC_imp, by = "Subject")
t_test_mult_cols <- function(df_basis, cols) {
df <- data.frame(t_statistic = numeric(length(cols)), p_value = numeric(length(cols)),
group_mean_Patients = numeric(length(cols)), sd_Patients = numeric(length(cols)),
group_mean_HC = numeric(length(cols)), sd_HC = numeric(length(cols)),
cohen_d = numeric(length(cols)))
rownames(df) <- cols
for (col in cols) {
# Using the non-formula interface
group0 <- na.omit(df_basis[df_basis[["Gruppe"]] == 0, col])
group1 <- na.omit(df_basis[df_basis[["Gruppe"]] == 1, col])
results <- t.test(group0, group1, paired = FALSE, var.equal = FALSE)
#Alternativ using formula method:
#results <- t.test(df_basis[[col]] ~ df_basis[["Gruppe"]], paired = FALSE, var.equal = FALSE)
# Calculate Cohen's d using the cohen.d function (effect size)
cohen_d_result <- cohen.d(group0, group1, hedges.correction = FALSE)
cohen_d <- cohen_d_result$estimate
# Calculate power using pwr.t.test (Bonferroni=0.007?; two-sided?)
n0 <- length(group0)
n1 <- length (group1)
power_result <- pwr.t.test(d = cohen_d, n = min(n0, n1), sig.level = 0.05, type = "two.sample", alternative = "greater")
power <- power_result$power
# Store the results
df[col, "t_statistic"] <- round(results$statistic, 2)
df[col, "p_value"] <- round(results$p.value, 2)
df[col, "group_mean_Patients"] <- round(mean(group1), 2)
df[col, "sd_Patients"] <- round(sd(group0), 2)
df[col, "group_mean_HC"] <- round(mean(group0), 2)
df[col, "sd_HC"] <- round(sd(group1), 2)
df[col, "cohen_d"] <- round(cohen_d, 2)
df[col, "power"] <- round(power, 2)
}
return(df)
}
t_test_table <- t_test_mult_cols(df_basis = Patients_vs_HC_imp, cols = imp_columns)
pander(t_test_table, style = "rmarkdown", fontsize = "tiny")
#Descriptive statistics
table1 <-
Patients_vs_HC_imp_conf %>%
tbl_summary(include = c(Alter, Geschlecht, Abschluss), by = Gruppe)
pander(as.data.frame(table1))
#ANCOVA
ANCOVA_mult_cols <- function(df_basis, cols, covariates = NULL){
# Create a overview of ANCOVA results for several columns in a dataframe
df <- data.frame(Gruppe_p_value = numeric(length(cols)))
rownames(df) <- cols
for (col in cols){
# Run ANCOVA
formula <- paste(col, " ~ Gruppe", ifelse(length(covariates) > 0, paste(" + ", paste(covariates, collapse = " + ")), ""))
anova_result <- aov(as.formula(formula), data = df_basis)
coefficients <- coef(anova_result)
summary_anova <- summary(anova_result)
#print(summary_anova)
# Prepare nice table to summarize the results
df[col, "Gruppe_p_value"] <- round(summary_anova[[1]]$"Pr(>F)"[1],2)
df[col, "Gruppe_corrected_difference"] <- round(coefficients[2],2)
df[col, "Alter_p_value"] <- round(summary_anova[[1]]$"Pr(>F)"[2],2)
df[col, "Geschlecht_p_value"] <- round(summary_anova[[1]]$"Pr(>F)"[3],2)
df[col, "Abschluss_p_value"] <- round(summary_anova[[1]]$"Pr(>F)"[4],2)
}
return(df)
}
table_ANCOVA <- ANCOVA_mult_cols(df_basis = Patients_vs_HC_imp_conf, cols = imp_columns, covariates = c("Alter","Geschlecht","Abschluss"))
pander(table_ANCOVA, style = "rmarkdown", fontsize = "tiny")
## Copy original dataframes
data_Pat_pre_comb <- data_Pat_pre
data_Pat_post_comb <- data_Pat_post
## Add timepoint-variable
data_Pat_pre_comb$time <- "pre"
data_Pat_post_comb$time <- "post"
# Combine data
data_Pat_pre_comb$Subject <- data_Pat_pre_comb$Subject + 600 # This was the ID given
Patients_pre_vs_post <- rbind(data_Pat_post_comb, data_Pat_pre_comb)
# Remove data if subjects had only pre-values
subject_counts <- table(Patients_pre_vs_post$Subject)
multiple_rows_subjects <- names(subject_counts)[subject_counts > 1]
Patients_pre_vs_post_clean <- Patients_pre_vs_post[Patients_pre_vs_post$Subject %in% multiple_rows_subjects, ]
# Reduce to BIS
#BIS_columns <- colnames(Patients_pre_vs_post_clean)[grep("BIS", colnames(Patients_pre_vs_post_clean))] # redundant
#imp_columns <- c(BIS_columns, "SSRT") # redundant
Patients_pre_vs_post_imp <- Patients_pre_vs_post_clean[,c("Subject",imp_columns,"time")]
#Helper function to avoid redundancy (Get pre and post data in one place for assumption and Welch test)
get_pre_post_data <- function(df_basis, col) {
pre_data <- df_basis[df_basis[["time"]] == "pre", col]
post_data <- df_basis[df_basis[["time"]] == "post", col]
return(list(pre = pre_data, post = post_data))
}
## Calculate Raw Pearson Correlation and Test Significance
calculate_correlations_and_significance <- function(df_basis, cols) {
df <- data.frame(Correlation = numeric(length(cols)), t_statistic = numeric(length(cols)),
p_value = numeric(length(cols)))
rownames(df) <- cols
for (col in cols) {
# Get pre and post data using the new function
data <- get_pre_post_data(df_basis, col)
# Use complete.cases to keep only rows where both pre AND post are not NA
complete_cases <- complete.cases(data$pre, data$post)
pre_data <- data$pre[complete_cases]
post_data <- data$post[complete_cases]
# Calculate Pearson correlation
correlation <- cor(pre_data, post_data)
# Calculate the t-statistic for the correlation
n <- length(pre_data)
t_statistic <- correlation * sqrt((n - 2) / (1 - correlation^2))
# Calculate the p-value for a one-tailed test (H_0: r ≤ 0)
p_value <- pt(t_statistic, df = n - 2, lower.tail = FALSE)
# Store the results
df[col, "Correlation"] <- round(correlation, 3)
df[col, "t_statistic"] <- round(t_statistic, 3)
df[col, "p_value"] <- round(p_value, 3)
}
return(df)
}
# Apply the correlation and significance test to your data
correlation_significance_table <- calculate_correlations_and_significance(df_basis = Patients_pre_vs_post_imp, cols = imp_columns)
pander(correlation_significance_table, style = "rmarkdown", fontsize = "tiny")
paired_t_test_mult_cols <- function(df_basis, cols) {
df <- data.frame(t_statistic = numeric(length(cols)), p_value = numeric(length(cols)),
group_mean_pre = numeric(length(cols)), group_mean_post = numeric(length(cols)),
cohen_d = numeric(length(cols)))
rownames(df) <- cols
for (col in cols) {
# Get pre and post data using get_pre_post_data helper function
data <- get_pre_post_data(df_basis, col)
# Use complete.cases to keep only rows where both pre AND post are not NA
complete_cases <- complete.cases(data$pre, data$post)
pre_data <- data$pre[complete_cases]
post_data <- data$post[complete_cases]
# non-formula interface as before
results <- t.test(pre_data, post_data, paired = TRUE, var.equal = FALSE)
#Alternativ using formula method:
#results <- t.test(df_basis[[col]] ~ df_basis[["time"]], paired = TRUE, var.equal = FALSE)
# Calculate Cohen's d using the cohen.d function for paired samples (effect size)
cohen_d_result <- cohen.d(post_data, pre_data, paired = TRUE)
cohen_d <- cohen_d_result$estimate
# Calculate power using pwr.t.test
n <- length(pre_data)
power_result <- pwr.t.test(d = cohen_d, n = n, sig.level = 0.05, type = "paired", alternative = "greater")
#0.007? (Bonferroni)
power <- power_result$power
# Store the results
df[col, "t_statistic"] <- round(results$statistic, 2)
df[col, "p_value"] <- round(results$p.value, 2)
df[col, "group_mean_pre"] <- round(mean(pre_data), 2)
df[col, "sd_pre"] <- round(sd(pre_data), 2)
df[col, "group_mean_post"] <- round(mean(post_data), 2)
df[col, "sd_post"] <- round(sd(post_data), 2)
df[col, "cohen_d"] <- round(cohen_d, 2)
df[col, "power"] <- round(power, 2)
}
return(df)
}
t_test_table_pre_post <- paired_t_test_mult_cols(df_basis = Patients_pre_vs_post_imp, cols = imp_columns)
pander(t_test_table_pre_post)
# Reshape data from wide to long format
Patients_vs_HC_long <- Patients_vs_HC_imp %>%
pivot_longer(cols = all_of(BIS_columns_renamed),
names_to = "Condition",
values_to = "BIS_Score")
# Reshape data from wide to long format
Patients_vs_HC_long <- Patients_vs_HC_imp %>%
pivot_longer(cols = all_of(imp_columns),
names_to = "Condition",
values_to = "BIS_Score")
# Add new task variable to keep the headers intact for faceting
Patients_vs_HC_long <- Patients_vs_HC_long %>%
mutate(Task = case_when(
grepl("NumberLetter", Condition) ~ "NumberLetter",
grepl("Stroop", Condition) ~ "Stroop",
grepl("TwoBack", Condition) ~ "TwoBack"
))
# Remove prefixes from Condition labels, keeping Task intact
Patients_vs_HC_long <- Patients_vs_HC_long %>%
mutate(Condition = gsub("NumberLetter_BIS_|Stroop_BIS_|TwoBack_BIS_", "", Condition))
# Convert "Gruppe" to factor
Patients_vs_HC_long$Gruppe <- factor(Patients_vs_HC_long$Gruppe, levels = c(0, 1), labels = c("Healthy Controls", "Patients"))
# Create boxplots # TODO: try violin-plot instead
boxplots_Patients_HC <- ggplot(Patients_vs_HC_long, aes(x = Condition, y = BIS_Score, color = Gruppe)) +
geom_boxplot(outlier.shape = NA) +
geom_jitter(position = position_jitterdodge(),
size = 0.7,
shape = 21,
fill = NA) +
facet_wrap(~ Task, scales = "free_x") +
#facet_grid(rows = vars(Task), scales = "free_x") +
labs(title = "Boxplots of Task Condition by Group",
x = "Condition",
y = "BIS-Score",
color = "Group")
# Create violin plots with mean
violin_plots_patients_hc <- ggplot(Patients_vs_HC_long, aes(x = Condition, y = BIS_Score, fill = Gruppe)) +
geom_violin(position = position_dodge(width = 0.8)) +
stat_summary(fun.data = mean_sdl, geom = "pointrange", # mult = 2 (SD) by default
position = position_dodge(width = 0.8)) + # width = 0.65, fatten = 2
facet_wrap(~ Task, scales = "free_x") +
labs(title = "Violin Plots of Task Condition by Group",
x = "Task Condition",
y = "BIS-Score",
fill = "Group")
violin_plots_patients_hc
# Reshape data from wide to long format
Patients_vs_HC_long <- Patients_vs_HC_imp %>%
pivot_longer(cols = all_of(BIS_columns), # imp_columns to include SSRT
names_to = "Condition",
values_to = "BIS_Score")
# Add new task variable to keep the headers intact for faceting
Patients_vs_HC_long <- Patients_vs_HC_long %>%
mutate(Task = case_when(
grepl("NumberLetter", Condition) ~ "NumberLetter",
grepl("Stroop", Condition) ~ "Stroop",
grepl("TwoBack", Condition) ~ "TwoBack"
))
# Remove prefixes from Condition labels, keeping Task intact
Patients_vs_HC_long <- Patients_vs_HC_long %>%
mutate(Condition = gsub("NumberLetter_BIS_|Stroop_BIS_|TwoBack_BIS_", "", Condition))
# Convert "Gruppe" to factor
Patients_vs_HC_long$Gruppe <- factor(Patients_vs_HC_long$Gruppe, levels = c(0, 1), labels = c("Healthy Controls", "Patients"))
# Create boxplots # TODO: try violin-plot instead
boxplots_Patients_HC <- ggplot(Patients_vs_HC_long, aes(x = Condition, y = BIS_Score, color = Gruppe)) +
geom_boxplot(outlier.shape = NA) +
geom_jitter(position = position_jitterdodge(),
size = 0.7,
shape = 21,
fill = NA) +
facet_wrap(~ Task, scales = "free_x") +
#facet_grid(rows = vars(Task), scales = "free_x") +
labs(title = "Boxplots of Task Condition by Group",
x = "Condition",
y = "BIS-Score",
color = "Group")
# Create violin plots with mean
violin_plots_patients_hc <- ggplot(Patients_vs_HC_long, aes(x = Condition, y = BIS_Score, fill = Gruppe)) +
geom_violin(position = position_dodge(width = 0.8)) +
stat_summary(fun.data = mean_sdl, geom = "pointrange", # mult = 2 (SD) by default
position = position_dodge(width = 0.8)) + # width = 0.65, fatten = 2
facet_wrap(~ Task, scales = "free_x") +
labs(title = "Violin Plots of Task Condition by Group",
x = "Task Condition",
y = "BIS-Score",
fill = "Group")
violin_plots_patients_hc
# Reshape data from wide to long format
Patients_pre_vs_post_long <- Patients_pre_vs_post_imp %>%
pivot_longer(cols = all_of(imp_columns), # imp_columns to include SSRT
names_to = "Condition",
values_to = "BIS_Score")
# Add new task variable
Patients_pre_vs_post_long <- Patients_pre_vs_post_long %>%
mutate(Task = case_when(
grepl("NumberLetter", Condition) ~ "NumberLetter",
grepl("Stroop", Condition) ~ "Stroop",
grepl("TwoBack", Condition) ~ "TwoBack"
))
# Remove prefixes from Condition labels, keeping Task intact
Patients_pre_vs_post_long <- Patients_pre_vs_post_long %>%
mutate(Condition = gsub("NumberLetter_BIS_|Stroop_BIS_|TwoBack_BIS_", "", Condition))
# Convert "time" to factor, specify order
Patients_pre_vs_post_long$time <- factor(Patients_pre_vs_post_long$time, levels = c("pre", "post"))
# Create boxplot with paired observations
boxplot_Patients_pre_post <- ggplot(Patients_pre_vs_post_long, aes(x = Condition, y = BIS_Score, color = time)) + # group = Subject
geom_boxplot(outlier.shape = NA) +
geom_jitter(position = position_jitterdodge(),
size = 0.7,
shape = 21,
fill = NA) +
#geom_line(aes(group = Subject)) +
facet_wrap(~ Task, scales = "free_x") +
labs(title = "Boxplots of Task Condition by Time of Measurement",
x = "Condition",
y = "BIS-Score",
color = "Time")
boxplot_Patients_pre_post
# Reshape data from wide to long format
Patients_pre_vs_post_long <- Patients_pre_vs_post_imp %>%
pivot_longer(cols = all_of(BIS_columns), # imp_columns to include SSRT
names_to = "Condition",
values_to = "BIS_Score")
# Add new task variable
Patients_pre_vs_post_long <- Patients_pre_vs_post_long %>%
mutate(Task = case_when(
grepl("NumberLetter", Condition) ~ "NumberLetter",
grepl("Stroop", Condition) ~ "Stroop",
grepl("TwoBack", Condition) ~ "TwoBack"
))
# Remove prefixes from Condition labels, keeping Task intact
Patients_pre_vs_post_long <- Patients_pre_vs_post_long %>%
mutate(Condition = gsub("NumberLetter_BIS_|Stroop_BIS_|TwoBack_BIS_", "", Condition))
# Convert "time" to factor, specify order
Patients_pre_vs_post_long$time <- factor(Patients_pre_vs_post_long$time, levels = c("pre", "post"))
# Create boxplot with paired observations
boxplot_Patients_pre_post <- ggplot(Patients_pre_vs_post_long, aes(x = Condition, y = BIS_Score, color = time)) + # group = Subject
geom_boxplot(outlier.shape = NA) +
geom_jitter(position = position_jitterdodge(),
size = 0.7,
shape = 21,
fill = NA) +
#geom_line(aes(group = Subject)) +
facet_wrap(~ Task, scales = "free_x") +
labs(title = "Boxplots of Task Condition by Time of Measurement",
x = "Condition",
y = "BIS-Score",
color = "Time")
boxplot_Patients_pre_post
