## Step 1: Calculate mean and SD for RT and PC across all healthy subjects and all conditions
Stroop_mean_sd_HC <- task_data_clean %>%
filter(Gruppe == 0) %>%
select(Stroop_Average_RT, Stroop_Average_PC) %>%
summarise(meanRT = mean(Stroop_Average_RT),
meanPC = mean(Stroop_Average_PC),
sdRT = sd(Stroop_Average_RT),
sdPC = sd(Stroop_Average_PC))
## Step 2: Standardize RT and PC for each condition
task_data_clean <- task_data_clean %>%
mutate(Z_Congruent_RT = (Congruent_RT - Stroop_mean_sd_HC$meanRT) / Stroop_mean_sd_HC$sdRT,
Z_Incongruent_RT = (Incongruent_RT - Stroop_mean_sd_HC$meanRT) / Stroop_mean_sd_HC$sdRT,
Z_Congruent_PC = (Congruent_PC - Stroop_mean_sd_HC$meanPC) / Stroop_mean_sd_HC$sdPC,
Z_Incongruent_PC = (Incongruent_PC - Stroop_mean_sd_HC$meanPC) / Stroop_mean_sd_HC$sdPC)
# Step 3: Calculate BIS(Congruent), BIS(Incongruent) and Difference Score
task_data_clean <- task_data_clean %>%
mutate(Stroop_BIS_Congruent = Z_Congruent_PC - Z_Congruent_RT,
Stroop_BIS_Incongruent = Z_Incongruent_PC - Z_Incongruent_RT) %>%
mutate(Stroop_BIS_Diff_Score = Stroop_BIS_Incongruent - Stroop_BIS_Congruent)
## Step 1: Calculate mean and SD for RT and PC across all healthy subjects and all conditions
TwoBack_mean_sd_HC <- task_data_clean %>%
filter(Gruppe == 0) %>%
select(TwoBack_Average_RT, TwoBack_Average_PC) %>%
summarise(meanRT = mean(TwoBack_Average_RT),
meanPC = mean(TwoBack_Average_PC),
sdRT = sd(TwoBack_Average_RT),
sdPC = sd(TwoBack_Average_PC))
## Step 2: Standardize RT and PC for each condition
task_data_clean <- task_data_clean %>%
mutate(Z_Total_RT = (TwoBack_Average_RT - TwoBack_mean_sd_HC$meanRT) / TwoBack_mean_sd_HC$sdRT,
Z_Target_RT = (Target_RT - TwoBack_mean_sd_HC$meanRT) / TwoBack_mean_sd_HC$sdRT,
Z_Foil_RT = (Foil_RT - TwoBack_mean_sd_HC$meanRT) / TwoBack_mean_sd_HC$sdRT,
Z_Total_PC = (TwoBack_Average_PC - TwoBack_mean_sd_HC$meanPC) / TwoBack_mean_sd_HC$sdPC,
Z_Target_PC = (Target_PC - TwoBack_mean_sd_HC$meanPC) / TwoBack_mean_sd_HC$sdPC,
Z_Foil_PC = (Foil_PC - TwoBack_mean_sd_HC$meanPC) / TwoBack_mean_sd_HC$sdPC)
# Calculate BIS(Target), BIS(Total) and BIS_Foil
task_data_clean <- task_data_clean %>%
mutate(TwoBack_BIS_Total = Z_Total_PC - Z_Total_RT,
TwoBack_BIS_Target = Z_Target_PC - Z_Target_RT,
TwoBack_BIS_Foil = Z_Foil_PC - Z_Foil_RT)
View(task_data_clean)
file_path_scores <- "Z:/Projekte_Meinke/Old_projects/Labrotation_Rebecca/Daten_Gruppenvergleich/With_wrong_responses/Performance_Scores/"
write.csv(task_data_clean, paste0(file_path_scores, "Task_Performance_Scores.csv"), row.names = FALSE)
# Reduce task data
task_data_clean_imp <- task_data_clean %>%
select(Subject, Gruppe, NumberLetter_BIS_Repeat, NumberLetter_BIS_Switch, NumberLetter_BIS_Diff_Score, Stroop_BIS_Congruent, Stroop_BIS_Incongruent, Stroop_BIS_Diff_Score, TwoBack_BIS_Foil, TwoBack_BIS_Target, TwoBack_BIS_Total, SSRT, T1_BAT_FAS_score, T3_BAT_FAS_score)
# Add sociodem. & clinical data
all_data <- left_join(x = task_data_clean_imp,
y = data_all %>% select(Subject,
Geschlecht,
Alter,
Abschluss,
T1_BAT_BDI_II_score,
T1_BAT_STAI_T_score,
T1_BAT_BIS_11_score,
T1_BAT_Kirby_k_score,
T1_BAT_CFC_14_score,
T1_BAT_SRHI_score),
by = "Subject")
all_data <- all_data %>%
mutate(Response = ifelse((T1_BAT_FAS_score.x - T3_BAT_FAS_score.x) >= 0.5 * T1_BAT_FAS_score.x, 1, 0))
all_data <- all_data %>%
mutate(Response = ifelse((T1_BAT_FAS_score - T3_BAT_FAS_score) >= 0.5 * T1_BAT_FAS_score, 1, 0))
View(all_data)
split_df <- split(all_data, all_data$Gruppe)
data_HC <- split_df$"0"
data_Pat_pre <- split_df$"1"
data_Pat_post <- split_df$"2"
# Remove Response column from data_HC
data_HC$Response <- NULL
View(data_HC)
split_df <- split(all_data, all_data$Gruppe)
data_HC <- split_df$"0"
data_Pat_pre <- split_df$"1"
data_Pat_post <- split_df$"2"
# Remove Response column from data_HC
# data_HC$Response <- NULL
file_path <- "Z:/Projekte_Meinke/Old_projects/Labrotation_Rebecca/Daten_Gruppenvergleich/With_wrong_responses/"
# Write data to CSV
write.csv(data_HC, paste0(file_path, "Data_HC.csv"), row.names = FALSE)
write.csv(data_Pat_pre, paste0(file_path, "Data_Patients_Pre.csv"), row.names = FALSE)
write.csv(data_Pat_post, paste0(file_path, "Data_Patients_Post.csv"), row.names = FALSE)
View(task_data_clean)
View(AllData_NumbLet)
View(AllData_NumbLet)
View(task_data_clean)
class(task_data_clean$Gruppe)
View(task_data_clean)
View(data_Pat_pre)
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE,rows.print = 6, cols.min.print = 3)
library(tidyverse)
basic_path <- "Z:/PsyThera/Projekte_Meinke/Old_projects/Labrotation_Rebecca/Daten_Gruppenvergleich/With_wrong_responses"
task_data <- read.csv(file.path(basic_path,"Performance_Scores/Task_Performance_Scores.csv"))
basic_path <- "Z:/PsyThera/Projekte_Meinke/Old_projects/Labrotation_Rebecca/Daten_Gruppenvergleich/With_wrong_responses"
task_data <- read.csv(file.path(basic_path,"Performance_Scores/Task_Performance_Scores.csv"))
basic_path <- "Z:/Projekte_Meinke/Old_projects/Labrotation_Rebecca/Daten_Gruppenvergleich/With_wrong_responses"
task_data <- read.csv(file.path(basic_path,"Performance_Scores/Task_Performance_Scores.csv"))
data_pat_pre <- read.csv(file.path(basic_path,"Data_Patients_Pre.csv"))
features_df <- left_join(x = data_pat_pre,
y = task_data %>% select(NumbLet_Average_PC, Stroop_Average_PC,
TwoBack_Average_PC))
features_df <- left_join(x = data_pat_pre,
y = task_data %>% select(Subject, NumbLet_Average_PC,
Stroop_Average_PC,
TwoBack_Average_PC),
by = "Subject")
View(features_df)
labels_df <- features_df["Response"]
features_df$Response <- NULL
View(labels_df)
View(features_df)
# 1. OneHot-Encoding of variable "Abschluss"
features_df$Abschluss <- as.character(features_df$Abschluss)
dummy <- dummyVars(" ~ Abschluss", data = features_df)
library(caret)
# 1. OneHot-Encoding of variable "Abschluss"
features_df$Abschluss <- as.character(features_df$Abschluss)
dummy <- dummyVars(" ~ Abschluss", data = features_df)
trsf <- data.frame(predict(dummy, newdata = features_df, fullRank=TRUE))
features_df_enc <- cbind(features_df, trsf)
# 2. Drop original variable "Subject", "Abschluss" and "T3_BAT_FAS_score"
features_df_enc$Subject <- NULL
features_df_enc$Abschluss <- NULL
features_df_enc$T3_BAT_FAS_score <- NULL
View(features_df_enc)
features_df_enc <- features_df_enc %>%
rename(is_woman = Geschlecht,
Age = Alter,
FAS = T1_BAT_FAS_score,
BDI_II = T1_BAT_BDI_II_score,
STAI_T = T1_BAT_STAI_T_score,
BIS = T1_BAT_BIS_11_score,
Kirby_k = T1_BAT_Kirby_k_score,
CFC_14 = T1_BAT_CFC_14_score,
SRHI = T1_BAT_SRHI_score,
Hauptschule = Abschluss1,
Realschule = Abschluss2,
Abitur = Abschluss3,
anderer_Abschluss = Abschluss4)
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(dplyr)
library(tidyr)
library(pander)
library(effsize)
library(pwr)
library(gtsummary)
library(stats)
basic_path_taskdata = "Y:/PsyThera/Projekte_Meinke/Old_projects/Labrotation_Rebecca/Daten_Gruppenvergleich/With_wrong_responses"
data_HC <- read.csv(file.path(basic_path,"Data_HC.csv"))
basic_path_taskdata = "Y:/PsyThera/Projekte_Meinke/Old_projects/Labrotation_Rebecca/Daten_Gruppenvergleich/With_wrong_responses"
data_HC <- read.csv(file.path(basic_path_taskdata,"Data_HC.csv"))
basic_path_taskdata = "Z:/PsyThera/Projekte_Meinke/Old_projects/Labrotation_Rebecca/Daten_Gruppenvergleich/With_wrong_responses"
data_HC <- read.csv(file.path(basic_path_taskdata,"Data_HC.csv"))
basic_path_taskdata = "Z:/Projekte_Meinke/Old_projects/Labrotation_Rebecca/Daten_Gruppenvergleich/With_wrong_responses"
data_HC <- read.csv(file.path(basic_path_taskdata,"Data_HC.csv"))
data_Pat_pre <- read.csv(file.path(basic_path_taskdata,"Data_Patients_Pre.csv"))
data_Pat_post <- read.csv(file.path(basic_path_taskdata,"Data_Patients_Post.csv"))
install.packages("DT")
install.packages("kableExtra")
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(dplyr)
library(tidyr)
library(pander)
library(effsize)
library(pwr)
library(gtsummary)
library(stats)
library(stats)
library(lmtest)
library(sandwich)
library(nlme)
library(car)
basic_path = "Z:/Projekte_Meinke/Old_projects/Labrotation_Rebecca/Daten_Gruppenvergleich/With_wrong_responses"
data_HC <- read.csv(file.path(basic_path,"Data_HC.csv"))
data_Pat_pre <- read.csv(file.path(basic_path,"Data_Patients_Pre.csv"))
data_Pat_post <- read.csv(file.path(basic_path,"Data_Patients_Post.csv"))
## 1. Merge patients pre and controls
Patients_vs_HC <- rbind(data_Pat_pre, data_HC)
## 2. Reduce dataset to executive functions of interest (BIS columns and SSRT)
BIS_columns <- colnames(Patients_vs_HC)[grep("BIS", colnames(Patients_vs_HC))]
imp_columns <- c(BIS_columns, "SSRT")
Patients_vs_HC_imp <- Patients_vs_HC[,c("Subject","Gruppe",imp_columns)]
## 3. Add confounds (Alter, Geschlecht, Abschluss)
Patients_vs_HC_imp_conf <- merge(Patients_vs_HC[,c("Subject","Alter","Geschlecht","Abschluss")], Patients_vs_HC_imp, by = "Subject")
# Ensure "Gruppe" is treated as a factor
Patients_vs_HC_imp$Gruppe <- as.factor(Patients_vs_HC_imp$Gruppe)
# Function to perform Levene's test on multiple columns
levene_test_mult_cols <- function(df_basis, cols) {
df <- data.frame(p_value = numeric(length(cols)))
rownames(df) <- cols
for (i in seq_along(cols)) {
col <- cols[i]
# Perform Levene's test, treating 'Gruppe' as a factor
levene_result <- leveneTest(df_basis[[col]] ~ df_basis[["Gruppe"]])
df[col, "p_value"] <- round(levene_result[1, "Pr(>F)"], 4)
}
return(df)
}
# Perform Levene's test for homogeneity of variance
levene_test_table <- levene_test_mult_cols(df_basis = Patients_vs_HC_imp, cols = imp_columns)
pander(levene_test_table, style = "rmarkdown", fontsize = "tiny")
t_test_mult_cols <- function(df_basis, cols) {
# Caclualte a t-test for multiple comparisons and store the results in a dataframe
df <- data.frame(t_statistic = numeric(length(cols)), p_value = numeric(length(cols)),
group_mean_Patients = numeric(length(cols)), sd_Patients = numeric(length(cols)),
group_mean_HC = numeric(length(cols)), sd_HC = numeric(length(cols)),
cohen_d = numeric(length(cols)))
rownames(df) <- cols
p_values_raw <- numeric(length(cols))  # Vector to store raw p-values
for (i in seq_along(cols)) {
col <- cols[i] #seq_along for sequencing column indices
# Using the non-formula interface
group0 <- na.omit(df_basis[df_basis[["Gruppe"]] == 0, col])
group1 <- na.omit(df_basis[df_basis[["Gruppe"]] == 1, col])
results <- t.test(group0, group1, paired = FALSE, var.equal = FALSE)
#Alternativ using formula method:
#results <- t.test(df_basis[[col]] ~ df_basis[["Gruppe"]], paired = FALSE, var.equal = FALSE)
# Store raw p-values for BH correction
p_values_raw[i] <- results$p.value
# Calculate Cohen's d using the cohen.d function (effect size)
cohen_d_result <- cohen.d(group0, group1, hedges.correction = FALSE)
cohen_d <- cohen_d_result$estimate
# Calculate power using pwr.t.test
n0 <- length(group0)
n1 <- length(group1)
power_result <- pwr.t.test(d = cohen_d, n = min(n0, n1), sig.level = 0.05, type = "two.sample", alternative = "greater")
power <- power_result$power
# Store the results
df[col, "t_statistic"] <- round(results$statistic, 2)
df[col, "p_value"] <- round(results$p.value, 2)
df[col, "group_mean_Patients"] <- round(mean(group1), 2)
df[col, "sd_Patients"] <- round(sd(group0), 2)
df[col, "group_mean_HC"] <- round(mean(group0), 2)
df[col, "sd_HC"] <- round(sd(group1), 2)
df[col, "cohen_d"] <- round(cohen_d, 2)
df[col, "power"] <- round(power, 2)
}
# Adjust p-values using Benjamini-Hochberg method for multiple testing of related tasks
p_values_adjusted <- p.adjust(p_values_raw, method = "BH")
df$p_value_adjusted <- round(p_values_adjusted, 2)
return(df)
}
t_test_table <- t_test_mult_cols(df_basis = Patients_vs_HC_imp, cols = imp_columns)
pander(t_test_table, style = "rmarkdown", fontsize = "tiny")
#ANCOVA
ANCOVA_mult_cols <- function(df_basis, cols, covariates = NULL){
# Create a overview of ANCOVA results for several columns in a dataframe
df <- data.frame(Gruppe_p_value = numeric(length(cols)))
rownames(df) <- cols
for (col in cols){
# Run ANCOVA
formula <- paste(col, " ~ Gruppe", ifelse(length(covariates) > 0, paste(" + ", paste(covariates, collapse = " + ")), ""))
anova_result <- aov(as.formula(formula), data = df_basis)
coefficients <- coef(anova_result)
summary_anova <- summary(anova_result)
#print(summary_anova)
# Prepare nice table to summarize the results
df[col, "Gruppe_p_value"] <- round(summary_anova[[1]]$"Pr(>F)"[1],2)
df[col, "Gruppe_corrected_difference"] <- round(coefficients[2],2)
df[col, "Alter_p_value"] <- round(summary_anova[[1]]$"Pr(>F)"[2],2)
df[col, "Geschlecht_p_value"] <- round(summary_anova[[1]]$"Pr(>F)"[3],2)
df[col, "Abschluss_p_value"] <- round(summary_anova[[1]]$"Pr(>F)"[4],2)
}
return(df)
}
table_ANCOVA <- ANCOVA_mult_cols(df_basis = Patients_vs_HC_imp_conf, cols = imp_columns, covariates = c("Alter","Geschlecht","Abschluss"))
pander(table_ANCOVA, style = "rmarkdown", fontsize = "tiny")
# 1. Identify common subjects in both datasets
data_Pat_pre$Subject_postID <- data_Pat_pre$Subject + 600 # IDs at post = ID at pre + 600
common_subjects_postID <- intersect(data_Pat_pre$Subject_postID, data_Pat_post$Subject) #Using intersect function to exclude only pre/post cases
# 2. Filter the datasets to only include common subjects
data_Pat_pre_filtered <- data_Pat_pre[data_Pat_pre$Subject_postID %in% common_subjects_postID , ]
data_Pat_post_filtered <- data_Pat_post[data_Pat_post$Subject %in% common_subjects_postID , ]
# 3. Important columns
data_Pat_pre_filtered_imp <- data_Pat_pre_filtered[, c("Subject", imp_columns)]
data_Pat_post_filtered_imp <- data_Pat_post_filtered[, c("Subject", imp_columns)]
paired_t_test_mult_cols <- function(pre_data, post_data, cols) {
df <- data.frame(t_statistic = numeric(length(cols)), p_value = numeric(length(cols)),
group_mean_pre = numeric(length(cols)), group_mean_post = numeric(length(cols)),
cohen_d = numeric(length(cols)))
rownames(df) <- cols
p_values_raw <- numeric(length(cols)) # Vector to store raw p-values
for (i in seq_along(cols)) {
col <- cols[i]
# Use complete.cases to keep only rows where both pre AND post are not NA
complete_cases <- complete.cases(pre_data[[col]], post_data[[col]])
pre_col_data <- pre_data[[col]][complete_cases]
post_col_data <- post_data[[col]][complete_cases]
# Check if there are at least 2 complete pairs of observations
if (length(pre_col_data) < 2 || length(post_col_data) < 2) {
warning(paste("Not enough data for column:", col))
df[col, ] <- NA  # Assign NA to the row in case of insufficient data
next  # Skip to the next column
}
# Perform paired Welch t-test (non-formula interface)
results <- t.test(pre_col_data, post_col_data, paired = TRUE, var.equal = FALSE)
#Alternativ using formula method:
#results <- t.test(df_basis[[col]] ~ df_basis[["time"]], paired = TRUE, var.equal = FALSE)
# Store raw p-values for BH correction
p_values_raw[i] <- results$p.value
# Calculate Cohen's d for paired samples (effect size)
cohen_d_result <- cohen.d(post_col_data, pre_col_data, paired = TRUE)
cohen_d <- cohen_d_result$estimate
# Calculate power using pwr.t.test
n <- length(pre_col_data)
power_result <- pwr.t.test(d = cohen_d, n = n, sig.level = 0.05, type = "paired", alternative = "greater")
power <- power_result$power
# Store the results
df[col, "t_statistic"] <- round(results$statistic, 2)
df[col, "p_value"] <- round(results$p.value, 2)
df[col, "group_mean_pre"] <- round(mean(pre_col_data), 2)
df[col, "sd_pre"] <- round(sd(pre_col_data), 2)
df[col, "group_mean_post"] <- round(mean(post_col_data), 2)
df[col, "sd_post"] <- round(sd(post_col_data), 2)
df[col, "cohen_d"] <- round(cohen_d, 2)
df[col, "power"] <- round(power, 2)
}
# Adjust p-values using Benjamini-Hochberg method for multiple testing of related tasks
p_values_adjusted <- p.adjust(p_values_raw, method = "BH")
df$p_value_adjusted <- round(p_values_adjusted, 2)
return(df)
}
# Apply the paired Welch t-test to your data
t_test_table_pre_post <- paired_t_test_mult_cols(pre_data = data_Pat_pre_filtered_imp, post_data = data_Pat_post_filtered_imp, cols = imp_columns)
pander(t_test_table_pre_post)
View(data_Pat_pre_filtered_imp)
View(data_Pat_post_filtered_imp)
imp_columns
# Reshape data from wide to long format
Patients_vs_HC_long <- Patients_vs_HC_imp %>%
pivot_longer(cols = all_of(BIS_columns), # imp_columns to include SSRT
names_to = "Condition",
values_to = "BIS_Score")
# Add new task variable to keep the headers intact for faceting
Patients_vs_HC_long <- Patients_vs_HC_long %>%
mutate(Task = case_when(
grepl("NumberLetter", Condition) ~ "NumberLetter",
grepl("Stroop", Condition) ~ "Stroop",
grepl("TwoBack", Condition) ~ "TwoBack"
))
# Remove prefixes from Condition labels, keeping Task intact
Patients_vs_HC_long <- Patients_vs_HC_long %>%
mutate(Condition = gsub("NumberLetter_BIS_|Stroop_BIS_|TwoBack_BIS_", "", Condition))
# Convert "Gruppe" to factor # TODO: change order of the conditions for consistency
Patients_vs_HC_long$Gruppe <- factor(Patients_vs_HC_long$Gruppe, levels = c(0, 1), labels = c("Healthy Controls", "Patients"))
# Create boxplots
boxplots_Patients_HC <- ggplot(Patients_vs_HC_long, aes(x = Condition, y = BIS_Score, color = Gruppe)) +
geom_boxplot(outlier.shape = NA) +
geom_jitter(position = position_jitterdodge(),
size = 0.7,
shape = 21,
fill = NA) +
facet_wrap(~ Task, scales = "free_x") +
#facet_grid(rows = vars(Task), scales = "free_x") +
labs(title = "Boxplots of Task Condition by Group",
x = "Condition",
y = "BIS-Score",
color = "Group")
# Create violin plots with mean
violin_plots_patients_hc <- ggplot(Patients_vs_HC_long, aes(x = Condition, y = BIS_Score, fill = Gruppe)) +
geom_violin(position = position_dodge(width = 0.8)) +
stat_summary(fun.data = mean_sdl, geom = "pointrange", # mult = 2 (SD) by default
position = position_dodge(width = 0.8)) + # width = 0.65, fatten = 2
facet_wrap(~ Task, scales = "free_x") +
labs(title = "Violin Plots of Task Condition by Group",
x = "Task Condition",
y = "BIS-Score",
fill = "Group")
boxplots_Patients_HC
View(Patients_vs_HC_imp)
BIS_columns
BIS_columns <- BIS_columns[BIS_columns != "T1_BAT_BIS_11_score"] # BIS-11 is a questionnaire
# Reshape data from wide to long format
Patients_vs_HC_long <- Patients_vs_HC_imp %>%
pivot_longer(cols = all_of(BIS_columns), # imp_columns to include SSRT
names_to = "Condition",
values_to = "BIS_Score")
# Add new task variable to keep the headers intact for faceting
Patients_vs_HC_long <- Patients_vs_HC_long %>%
mutate(Task = case_when(
grepl("NumberLetter", Condition) ~ "NumberLetter",
grepl("Stroop", Condition) ~ "Stroop",
grepl("TwoBack", Condition) ~ "TwoBack"
))
# Remove prefixes from Condition labels, keeping Task intact
Patients_vs_HC_long <- Patients_vs_HC_long %>%
mutate(Condition = gsub("NumberLetter_BIS_|Stroop_BIS_|TwoBack_BIS_", "", Condition))
# Convert "Gruppe" to factor # TODO: change order of the conditions for consistency
Patients_vs_HC_long$Gruppe <- factor(Patients_vs_HC_long$Gruppe, levels = c(0, 1), labels = c("Healthy Controls", "Patients"))
# Create boxplots
boxplots_Patients_HC <- ggplot(Patients_vs_HC_long, aes(x = Condition, y = BIS_Score, color = Gruppe)) +
geom_boxplot(outlier.shape = NA) +
geom_jitter(position = position_jitterdodge(),
size = 0.7,
shape = 21,
fill = NA) +
facet_wrap(~ Task, scales = "free_x") +
#facet_grid(rows = vars(Task), scales = "free_x") +
labs(title = "Boxplots of Task Condition by Group",
x = "Condition",
y = "BIS-Score",
color = "Group")
# Create violin plots with mean
violin_plots_patients_hc <- ggplot(Patients_vs_HC_long, aes(x = Condition, y = BIS_Score, fill = Gruppe)) +
geom_violin(position = position_dodge(width = 0.8)) +
stat_summary(fun.data = mean_sdl, geom = "pointrange", # mult = 2 (SD) by default
position = position_dodge(width = 0.8)) + # width = 0.65, fatten = 2
facet_wrap(~ Task, scales = "free_x") +
labs(title = "Violin Plots of Task Condition by Group",
x = "Task Condition",
y = "BIS-Score",
fill = "Group")
boxplots_Patients_HC
violin_plots_patients_hc
# Add a timepoint variable to the filtered datasets and combine
data_Pat_pre_filtered_imp$time <- "pre"
data_Pat_post_filtered_imp$time <- "post"
Patients_pre_vs_post_long <- rbind(data_Pat_pre_filtered_imp, data_Pat_post_filtered_imp)
# Reshape data from wide to long format
Patients_pre_vs_post_long <- Patients_pre_vs_post_long %>%
pivot_longer(cols = all_of(BIS_columns), # imp_columns to include SSRT
names_to = "Condition",
values_to = "BIS_Score")
# Add new task variable
Patients_pre_vs_post_long <- Patients_pre_vs_post_long %>%
mutate(Task = case_when(
grepl("NumberLetter", Condition) ~ "NumberLetter",
grepl("Stroop", Condition) ~ "Stroop",
grepl("TwoBack", Condition) ~ "TwoBack"
))
# Remove prefixes from Condition labels, keeping Task intact
Patients_pre_vs_post_long <- Patients_pre_vs_post_long %>%
mutate(Condition = gsub("NumberLetter_BIS_|Stroop_BIS_|TwoBack_BIS_", "", Condition))
# Convert "time" to factor, specify order
Patients_pre_vs_post_long$time <- factor(Patients_pre_vs_post_long$time, levels = c("pre", "post"))
# Create boxplot with paired observations
boxplot_Patients_pre_post <- ggplot(Patients_pre_vs_post_long, aes(x = Condition, y = BIS_Score, color = time)) + # group = Subject
geom_boxplot(outlier.shape = NA) +
geom_jitter(position = position_jitterdodge(),
size = 0.7,
shape = 21,
fill = NA) +
#geom_line(aes(group = Subject)) + # optional, if you want to visualize pairing
facet_wrap(~ Task, scales = "free_x") +
labs(title = "Boxplots of Task Condition by Time of Measurement",
x = "Condition",
y = "BIS-Score",
color = "Time")
boxplot_Patients_pre_post
basic_path <- "Z:/Projekte_Meinke/Old_projects/Labrotation_Rebecca/Daten_Gruppenvergleich/With_wrong_responses"
task_data <- read.csv(file.path(basic_path,"Performance_Scores/Task_Performance_Scores.csv"))
data_pat_pre <- read.csv(file.path(basic_path,"Data_Patients_Pre.csv"))
View(task_data)
View(task_data)
View(data_pat_pre)
features_df <- left_join(x = data_pat_pre,
y = task_data %>% select(Subject, NumbLet_Average_PC,
Stroop_Average_PC,
TwoBack_Average_PC),
by = "Subject")
library(dplyr)
features_df <- left_join(x = data_pat_pre,
y = task_data %>% select(Subject, NumbLet_Average_PC,
Stroop_Average_PC,
TwoBack_Average_PC),
by = "Subject")
View(features_df)
labels_df <- features_df["Response"]
features_df$Response <- NULL
features_df$percent_diff <- ((features_df$T3_BAT_FAS_score - features_df$T1_BAT_FAS_score) / features_df$T1_BAT_FAS_score) * 100
View(features_df)
class(features_df$Abschluss)
features_df$Abschluss <- as.character(features_df$Abschluss)
dummy <- dummyVars(" ~ Abschluss", data = features_df)
library(caret)
features_df$Abschluss <- as.character(features_df$Abschluss)
dummy <- dummyVars(" ~ Abschluss", data = features_df)
trsf <- data.frame(predict(dummy, newdata = features_df, fullRank=TRUE))
features_df_enc <- cbind(features_df, trsf)
features_df_enc$Subject <- NULL
features_df_enc$Abschluss <- NULL
features_df_enc$T3_BAT_FAS_score <- NULL
features_df_enc <- features_df_enc %>%
rename(is_woman = Geschlecht,
Age = Alter,
FAS = T1_BAT_FAS_score,
BDI_II = T1_BAT_BDI_II_score,
STAI_T = T1_BAT_STAI_T_score,
BIS = T1_BAT_BIS_11_score,
Kirby_k = T1_BAT_Kirby_k_score,
CFC_14 = T1_BAT_CFC_14_score,
SRHI = T1_BAT_SRHI_score,
Hauptschule = Abschluss1,
Realschule = Abschluss2,
Abitur = Abschluss3,
anderer_Abschluss = Abschluss4)
View(features_df_enc)
#var_category <- find_bin_cols(features_df_enc_clean)
# TEST
bin_cols <- c("is_woman", "Hauptschule", "Realschule", "Abitur", "anderer_Abschluss")
non_bin_cols <- setdiff(names(features_df_enc), bin_cols)
# TODO: Replace bin_cols with var_category$binary and non_bin_cols with var_category$non_binary as soon as function find_bin_cols works
for (feature in bin_cols) {
features_df_enc[[feature]][is.na(features_df_enc[[feature]])] <- 77777
}
for (feature in non_bin_cols) {
features_df_enc[[feature]][is.na(features_df_enc[[feature]])] <- 99999
}
clin_features <- c("is_woman", "Age", "FAS_Score", "BDI_II_Score", "STAI_T_Score", "BIS_Score", "Kirby_k_Score", "CFC_Score", "SRHI_Score", "Hauptschule", "Realschule", "Abitur", "anderer_Abschluss")
clin_features_df_enc <- features_df_enc[clin_features]
