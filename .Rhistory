df <- data.frame(Gruppe_p_value = numeric(length(cols)))
rownames(df) <- cols
for (col in cols){
# Run ANCOVA
formula <- paste(col, " ~ Gruppe", ifelse(length(covariates) > 0, paste(" + ", paste(covariates, collapse = " + ")), ""))
anova_result <- aov(as.formula(formula), data = df_basis)
coefficients <- coef(anova_result)
summary_anova <- summary(anova_result)
#print(summary_anova)
# Prepare nice table to summarize the results
df[col, "Gruppe_p_value"] <- round(summary_anova[[1]]$"Pr(>F)"[1],2)
df[col, "Gruppe_corrected_difference"] <- round(coefficients[2],2)
df[col, "Alter_p_value"] <- round(summary_anova[[1]]$"Pr(>F)"[2],2)
df[col, "Geschlecht_p_value"] <- round(summary_anova[[1]]$"Pr(>F)"[3],2)
df[col, "Abschluss_p_value"] <- round(summary_anova[[1]]$"Pr(>F)"[4],2)
}
return(df)
}
table_ANCOVA <- ANCOVA_mult_cols(df_basis = Patients_vs_HC_imp_conf, cols = imp_columns, covariates = c("Alter","Geschlecht","Abschluss"))
pander(table_ANCOVA, style = "rmarkdown", fontsize = "tiny")
# 1. Identify common subjects in both datasets
data_Pat_pre$Subject_postID <- data_Pat_pre$Subject + 600 # IDs at post = ID at pre + 600
common_subjects_postID <- intersect(data_Pat_pre$Subject_postID, data_Pat_post$Subject) #Using intersect function to exclude only pre/post cases
# 2. Filter the datasets to only include common subjects
data_Pat_pre_filtered <- data_Pat_pre[data_Pat_pre$Subject_postID %in% common_subjects_postID , ]
data_Pat_post_filtered <- data_Pat_post[data_Pat_post$Subject %in% common_subjects_postID , ]
# 3. Important columns
data_Pat_pre_filtered_imp <- data_Pat_pre_filtered[, c("Subject", imp_columns)]
data_Pat_post_filtered_imp <- data_Pat_post_filtered[, c("Subject", imp_columns)]
paired_t_test_mult_cols <- function(pre_data, post_data, cols) {
df <- data.frame(t_statistic = numeric(length(cols)), p_value = numeric(length(cols)),
group_mean_pre = numeric(length(cols)), group_mean_post = numeric(length(cols)),
cohen_d = numeric(length(cols)))
rownames(df) <- cols
p_values_raw <- numeric(length(cols)) # Vector to store raw p-values
for (i in seq_along(cols)) {
col <- cols[i]
# Use complete.cases to keep only rows where both pre AND post are not NA
complete_cases <- complete.cases(pre_data[[col]], post_data[[col]])
pre_col_data <- pre_data[[col]][complete_cases]
post_col_data <- post_data[[col]][complete_cases]
# Check if there are at least 2 complete pairs of observations
if (length(pre_col_data) < 2 || length(post_col_data) < 2) {
warning(paste("Not enough data for column:", col))
df[col, ] <- NA  # Assign NA to the row in case of insufficient data
next  # Skip to the next column
}
# Perform paired Welch t-test (non-formula interface)
results <- t.test(pre_col_data, post_col_data, paired = TRUE, var.equal = FALSE)
#Alternativ using formula method:
#results <- t.test(df_basis[[col]] ~ df_basis[["time"]], paired = TRUE, var.equal = FALSE)
# Store raw p-values for BH correction
p_values_raw[i] <- results$p.value
# Calculate Cohen's d for paired samples (effect size)
cohen_d_result <- cohen.d(post_col_data, pre_col_data, paired = TRUE)
cohen_d <- cohen_d_result$estimate
# Calculate power using pwr.t.test
n <- length(pre_col_data)
power_result <- pwr.t.test(d = cohen_d, n = n, sig.level = 0.05, type = "paired", alternative = "greater")
power <- power_result$power
# Store the results
df[col, "t_statistic"] <- round(results$statistic, 2)
df[col, "p_value"] <- round(results$p.value, 2)
df[col, "group_mean_pre"] <- round(mean(pre_col_data), 2)
df[col, "sd_pre"] <- round(sd(pre_col_data), 2)
df[col, "group_mean_post"] <- round(mean(post_col_data), 2)
df[col, "sd_post"] <- round(sd(post_col_data), 2)
df[col, "cohen_d"] <- round(cohen_d, 2)
df[col, "power"] <- round(power, 2)
}
# Adjust p-values using Benjamini-Hochberg method for multiple testing of related tasks
p_values_adjusted <- p.adjust(p_values_raw, method = "BH")
df$p_value_adjusted <- round(p_values_adjusted, 2)
return(df)
}
# Apply the paired Welch t-test to your data
t_test_table_pre_post <- paired_t_test_mult_cols(pre_data = data_Pat_pre_filtered_imp, post_data = data_Pat_post_filtered_imp, cols = imp_columns)
pander(t_test_table_pre_post)
View(data_Pat_pre_filtered_imp)
View(data_Pat_post_filtered_imp)
imp_columns
# Reshape data from wide to long format
Patients_vs_HC_long <- Patients_vs_HC_imp %>%
pivot_longer(cols = all_of(BIS_columns), # imp_columns to include SSRT
names_to = "Condition",
values_to = "BIS_Score")
# Add new task variable to keep the headers intact for faceting
Patients_vs_HC_long <- Patients_vs_HC_long %>%
mutate(Task = case_when(
grepl("NumberLetter", Condition) ~ "NumberLetter",
grepl("Stroop", Condition) ~ "Stroop",
grepl("TwoBack", Condition) ~ "TwoBack"
))
# Remove prefixes from Condition labels, keeping Task intact
Patients_vs_HC_long <- Patients_vs_HC_long %>%
mutate(Condition = gsub("NumberLetter_BIS_|Stroop_BIS_|TwoBack_BIS_", "", Condition))
# Convert "Gruppe" to factor # TODO: change order of the conditions for consistency
Patients_vs_HC_long$Gruppe <- factor(Patients_vs_HC_long$Gruppe, levels = c(0, 1), labels = c("Healthy Controls", "Patients"))
# Create boxplots
boxplots_Patients_HC <- ggplot(Patients_vs_HC_long, aes(x = Condition, y = BIS_Score, color = Gruppe)) +
geom_boxplot(outlier.shape = NA) +
geom_jitter(position = position_jitterdodge(),
size = 0.7,
shape = 21,
fill = NA) +
facet_wrap(~ Task, scales = "free_x") +
#facet_grid(rows = vars(Task), scales = "free_x") +
labs(title = "Boxplots of Task Condition by Group",
x = "Condition",
y = "BIS-Score",
color = "Group")
# Create violin plots with mean
violin_plots_patients_hc <- ggplot(Patients_vs_HC_long, aes(x = Condition, y = BIS_Score, fill = Gruppe)) +
geom_violin(position = position_dodge(width = 0.8)) +
stat_summary(fun.data = mean_sdl, geom = "pointrange", # mult = 2 (SD) by default
position = position_dodge(width = 0.8)) + # width = 0.65, fatten = 2
facet_wrap(~ Task, scales = "free_x") +
labs(title = "Violin Plots of Task Condition by Group",
x = "Task Condition",
y = "BIS-Score",
fill = "Group")
boxplots_Patients_HC
View(Patients_vs_HC_imp)
BIS_columns
BIS_columns <- BIS_columns[BIS_columns != "T1_BAT_BIS_11_score"] # BIS-11 is a questionnaire
# Reshape data from wide to long format
Patients_vs_HC_long <- Patients_vs_HC_imp %>%
pivot_longer(cols = all_of(BIS_columns), # imp_columns to include SSRT
names_to = "Condition",
values_to = "BIS_Score")
# Add new task variable to keep the headers intact for faceting
Patients_vs_HC_long <- Patients_vs_HC_long %>%
mutate(Task = case_when(
grepl("NumberLetter", Condition) ~ "NumberLetter",
grepl("Stroop", Condition) ~ "Stroop",
grepl("TwoBack", Condition) ~ "TwoBack"
))
# Remove prefixes from Condition labels, keeping Task intact
Patients_vs_HC_long <- Patients_vs_HC_long %>%
mutate(Condition = gsub("NumberLetter_BIS_|Stroop_BIS_|TwoBack_BIS_", "", Condition))
# Convert "Gruppe" to factor # TODO: change order of the conditions for consistency
Patients_vs_HC_long$Gruppe <- factor(Patients_vs_HC_long$Gruppe, levels = c(0, 1), labels = c("Healthy Controls", "Patients"))
# Create boxplots
boxplots_Patients_HC <- ggplot(Patients_vs_HC_long, aes(x = Condition, y = BIS_Score, color = Gruppe)) +
geom_boxplot(outlier.shape = NA) +
geom_jitter(position = position_jitterdodge(),
size = 0.7,
shape = 21,
fill = NA) +
facet_wrap(~ Task, scales = "free_x") +
#facet_grid(rows = vars(Task), scales = "free_x") +
labs(title = "Boxplots of Task Condition by Group",
x = "Condition",
y = "BIS-Score",
color = "Group")
# Create violin plots with mean
violin_plots_patients_hc <- ggplot(Patients_vs_HC_long, aes(x = Condition, y = BIS_Score, fill = Gruppe)) +
geom_violin(position = position_dodge(width = 0.8)) +
stat_summary(fun.data = mean_sdl, geom = "pointrange", # mult = 2 (SD) by default
position = position_dodge(width = 0.8)) + # width = 0.65, fatten = 2
facet_wrap(~ Task, scales = "free_x") +
labs(title = "Violin Plots of Task Condition by Group",
x = "Task Condition",
y = "BIS-Score",
fill = "Group")
boxplots_Patients_HC
violin_plots_patients_hc
# Add a timepoint variable to the filtered datasets and combine
data_Pat_pre_filtered_imp$time <- "pre"
data_Pat_post_filtered_imp$time <- "post"
Patients_pre_vs_post_long <- rbind(data_Pat_pre_filtered_imp, data_Pat_post_filtered_imp)
# Reshape data from wide to long format
Patients_pre_vs_post_long <- Patients_pre_vs_post_long %>%
pivot_longer(cols = all_of(BIS_columns), # imp_columns to include SSRT
names_to = "Condition",
values_to = "BIS_Score")
# Add new task variable
Patients_pre_vs_post_long <- Patients_pre_vs_post_long %>%
mutate(Task = case_when(
grepl("NumberLetter", Condition) ~ "NumberLetter",
grepl("Stroop", Condition) ~ "Stroop",
grepl("TwoBack", Condition) ~ "TwoBack"
))
# Remove prefixes from Condition labels, keeping Task intact
Patients_pre_vs_post_long <- Patients_pre_vs_post_long %>%
mutate(Condition = gsub("NumberLetter_BIS_|Stroop_BIS_|TwoBack_BIS_", "", Condition))
# Convert "time" to factor, specify order
Patients_pre_vs_post_long$time <- factor(Patients_pre_vs_post_long$time, levels = c("pre", "post"))
# Create boxplot with paired observations
boxplot_Patients_pre_post <- ggplot(Patients_pre_vs_post_long, aes(x = Condition, y = BIS_Score, color = time)) + # group = Subject
geom_boxplot(outlier.shape = NA) +
geom_jitter(position = position_jitterdodge(),
size = 0.7,
shape = 21,
fill = NA) +
#geom_line(aes(group = Subject)) + # optional, if you want to visualize pairing
facet_wrap(~ Task, scales = "free_x") +
labs(title = "Boxplots of Task Condition by Time of Measurement",
x = "Condition",
y = "BIS-Score",
color = "Time")
boxplot_Patients_pre_post
basic_path <- "Z:/Projekte_Meinke/Old_projects/Labrotation_Rebecca/Daten_Gruppenvergleich/With_wrong_responses"
task_data <- read.csv(file.path(basic_path,"Performance_Scores/Task_Performance_Scores.csv"))
data_pat_pre <- read.csv(file.path(basic_path,"Data_Patients_Pre.csv"))
View(task_data)
View(task_data)
View(data_pat_pre)
features_df <- left_join(x = data_pat_pre,
y = task_data %>% select(Subject, NumbLet_Average_PC,
Stroop_Average_PC,
TwoBack_Average_PC),
by = "Subject")
library(dplyr)
features_df <- left_join(x = data_pat_pre,
y = task_data %>% select(Subject, NumbLet_Average_PC,
Stroop_Average_PC,
TwoBack_Average_PC),
by = "Subject")
View(features_df)
labels_df <- features_df["Response"]
features_df$Response <- NULL
features_df$percent_diff <- ((features_df$T3_BAT_FAS_score - features_df$T1_BAT_FAS_score) / features_df$T1_BAT_FAS_score) * 100
View(features_df)
class(features_df$Abschluss)
features_df$Abschluss <- as.character(features_df$Abschluss)
dummy <- dummyVars(" ~ Abschluss", data = features_df)
library(caret)
features_df$Abschluss <- as.character(features_df$Abschluss)
dummy <- dummyVars(" ~ Abschluss", data = features_df)
trsf <- data.frame(predict(dummy, newdata = features_df, fullRank=TRUE))
features_df_enc <- cbind(features_df, trsf)
features_df_enc$Subject <- NULL
features_df_enc$Abschluss <- NULL
features_df_enc$T3_BAT_FAS_score <- NULL
features_df_enc <- features_df_enc %>%
rename(is_woman = Geschlecht,
Age = Alter,
FAS = T1_BAT_FAS_score,
BDI_II = T1_BAT_BDI_II_score,
STAI_T = T1_BAT_STAI_T_score,
BIS = T1_BAT_BIS_11_score,
Kirby_k = T1_BAT_Kirby_k_score,
CFC_14 = T1_BAT_CFC_14_score,
SRHI = T1_BAT_SRHI_score,
Hauptschule = Abschluss1,
Realschule = Abschluss2,
Abitur = Abschluss3,
anderer_Abschluss = Abschluss4)
View(features_df_enc)
#var_category <- find_bin_cols(features_df_enc_clean)
# TEST
bin_cols <- c("is_woman", "Hauptschule", "Realschule", "Abitur", "anderer_Abschluss")
non_bin_cols <- setdiff(names(features_df_enc), bin_cols)
# TODO: Replace bin_cols with var_category$binary and non_bin_cols with var_category$non_binary as soon as function find_bin_cols works
for (feature in bin_cols) {
features_df_enc[[feature]][is.na(features_df_enc[[feature]])] <- 77777
}
for (feature in non_bin_cols) {
features_df_enc[[feature]][is.na(features_df_enc[[feature]])] <- 99999
}
clin_features <- c("is_woman", "Age", "FAS_Score", "BDI_II_Score", "STAI_T_Score", "BIS_Score", "Kirby_k_Score", "CFC_Score", "SRHI_Score", "Hauptschule", "Realschule", "Abitur", "anderer_Abschluss")
clin_features_df_enc <- features_df_enc[clin_features]
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE,rows.print = 6, cols.min.print = 3)
library(dplyr)
library(tidyverse)
library(caret)
basic_path <- "Z:/Projekte_Meinke/Old_projects/Labrotation_Rebecca/Daten_Gruppenvergleich/With_wrong_responses"
task_data <- read.csv(file.path(basic_path,"Performance_Scores/Task_Performance_Scores.csv")) # contains overall accuracy
data_pat_pre <- read.csv(file.path(basic_path,"Data_Patients_Pre.csv"))
features_df <- left_join(x = data_pat_pre,
y = task_data %>% select(Subject, NumbLet_Average_PC,
Stroop_Average_PC,
TwoBack_Average_PC),
by = "Subject")
View(features_df)
labels_df <- features_df["Response"]
features_df$Response <- NULL
features_df$FAS_perc_change <- ((features_df$T3_BAT_FAS_score - features_df$T1_BAT_FAS_score) / features_df$T1_BAT_FAS_score) * 100
# 1. OneHot-Encoding of variable "Abschluss"
features_df$Abschluss <- as.character(features_df$Abschluss)
dummy <- dummyVars(" ~ Abschluss", data = features_df)
trsf <- data.frame(predict(dummy, newdata = features_df, fullRank=TRUE))
features_df_enc <- cbind(features_df, trsf)
# 2. Drop variables "Abschluss", "Subject", "Gruppe", and "T3_BAT_FAS_score"
features_df_enc$Subject <- NULL
features_df_enc$Gruppe <- NULL
features_df_enc$Abschluss <- NULL
features_df_enc$T3_BAT_FAS_score <- NULL
# 3. Rename columns
features_df_enc <- features_df_enc %>%
rename(is_woman = Geschlecht,
Age = Alter,
FAS = T1_BAT_FAS_score,
BDI_II = T1_BAT_BDI_II_score,
STAI_T = T1_BAT_STAI_T_score,
BIS_11 = T1_BAT_BIS_11_score,
Kirby_k = T1_BAT_Kirby_k_score,
CFC_14 = T1_BAT_CFC_14_score,
SRHI = T1_BAT_SRHI_score,
Hauptschule = Abschluss1,
Realschule = Abschluss2,
Abitur = Abschluss3,
anderer_Abschluss = Abschluss4)
View(features_df_enc)
#var_category <- find_bin_cols(features_df_enc_clean)
# TEST
bin_cols <- c("is_woman", "Hauptschule", "Realschule", "Abitur", "anderer_Abschluss")
non_bin_cols <- setdiff(names(features_df_enc), bin_cols)
# TODO: Replace bin_cols with var_category$binary and non_bin_cols with var_category$non_binary as soon as function find_bin_cols works
for (feature in bin_cols) {
features_df_enc[[feature]][is.na(features_df_enc[[feature]])] <- 77777
}
for (feature in non_bin_cols) {
features_df_enc[[feature]][is.na(features_df_enc[[feature]])] <- 99999
}
clin_features <- c("is_woman", "Age", "FAS", "BDI_II", "STAI_T", "BIS_11", "Kirby_k", "CFC_14", "SRHI", "Hauptschule", "Realschule", "Abitur", "anderer_Abschluss")
clin_features_df_enc <- features_df_enc[clin_features]
View(clin_features_df_enc)
file_path <- "Z:/PsyThera/Projekte_Meinke/Labrotation_Rebecca/Feature_Label_Dataframes/"
write.csv(features_df_enc, paste0(file_path, "Features.csv"), row.names = FALSE)
file_path <- "Z:/Projekte_Meinke/Old_projects/Labrotation_Rebecca/Feature_Label_Dataframes/"
write.csv(features_df_enc, paste0(file_path, "Features.csv"), row.names = FALSE)
write.csv(clin_features_df_enc, paste0(file_path, "Clinical_Features.csv"), row.names = FALSE)
write.csv(labels_df, paste0(file_path, "Labels.csv"), row.names = FALSE)
View(data_pat_pre)
View(data_pat_pre)
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE,rows.print = 6, cols.min.print = 3)
library(dplyr)
library(tidyverse)
library(caret)
basic_path <- "Z:/Projekte_Meinke/Old_projects/Labrotation_Rebecca/Daten_Gruppenvergleich/With_wrong_responses"
task_data <- read.csv(file.path(basic_path,"Performance_Scores/Task_Performance_Scores.csv")) # contains overall accuracy
data_pat_pre <- read.csv(file.path(basic_path,"Data_Patients_Pre.csv"))
data_pat_pre_clean <- data_pat_pre %>%
filter(!is.na(Response)) # equals to NA at T1_BAT_FAS_score and/or T3_BAT_FAS_score
features_df <- left_join(x = data_pat_pre_clean,
y = task_data %>% select(Subject, NumbLet_Average_PC,
Stroop_Average_PC,
TwoBack_Average_PC),
by = "Subject")
labels_df <- features_df["Response"]
features_df$Response <- NULL
features_df$FAS_perc_change <- ((features_df$T3_BAT_FAS_score - features_df$T1_BAT_FAS_score) / features_df$T1_BAT_FAS_score) * 100
# 1. OneHot-Encoding of variable "Abschluss"
features_df$Abschluss <- as.character(features_df$Abschluss)
dummy <- dummyVars(" ~ Abschluss", data = features_df)
trsf <- data.frame(predict(dummy, newdata = features_df, fullRank=TRUE))
features_df_enc <- cbind(features_df, trsf)
# 2. Drop variables "Abschluss", "Subject", "Gruppe", and "T3_BAT_FAS_score"
features_df_enc$Subject <- NULL
features_df_enc$Gruppe <- NULL
features_df_enc$Abschluss <- NULL
features_df_enc$T3_BAT_FAS_score <- NULL
# 3. Rename columns
features_df_enc <- features_df_enc %>%
rename(is_woman = Geschlecht,
Age = Alter,
FAS = T1_BAT_FAS_score,
BDI_II = T1_BAT_BDI_II_score,
STAI_T = T1_BAT_STAI_T_score,
BIS_11 = T1_BAT_BIS_11_score,
Kirby_k = T1_BAT_Kirby_k_score,
CFC_14 = T1_BAT_CFC_14_score,
SRHI = T1_BAT_SRHI_score,
Hauptschule = Abschluss1,
Realschule = Abschluss2,
Abitur = Abschluss3,
anderer_Abschluss = Abschluss4)
#var_category <- find_bin_cols(features_df_enc_clean)
# TEST
bin_cols <- c("is_woman", "Hauptschule", "Realschule", "Abitur", "anderer_Abschluss")
non_bin_cols <- setdiff(names(features_df_enc), bin_cols)
# TODO: Replace bin_cols with var_category$binary and non_bin_cols with var_category$non_binary as soon as function find_bin_cols works
for (feature in bin_cols) {
features_df_enc[[feature]][is.na(features_df_enc[[feature]])] <- 77777
}
for (feature in non_bin_cols) {
features_df_enc[[feature]][is.na(features_df_enc[[feature]])] <- 99999
}
clin_features <- c("is_woman", "Age", "FAS", "BDI_II", "STAI_T", "BIS_11", "Kirby_k", "CFC_14", "SRHI", "Hauptschule", "Realschule", "Abitur", "anderer_Abschluss")
clin_features_df_enc <- features_df_enc[clin_features]
file_path <- "Z:/Projekte_Meinke/Old_projects/Labrotation_Rebecca/Feature_Label_Dataframes/"
write.csv(features_df_enc, paste0(file_path, "Features.csv"), row.names = FALSE)
write.csv(clin_features_df_enc, paste0(file_path, "Clinical_Features.csv"), row.names = FALSE)
write.csv(labels_df, paste0(file_path, "Labels.csv"), row.names = FALSE)
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE,rows.print = 6, cols.min.print = 3)
library(dplyr)
library(tidyverse)
library(caret)
basic_path <- "Z:/Projekte_Meinke/Old_projects/Labrotation_Rebecca/Daten_Gruppenvergleich/With_wrong_responses"
task_data <- read.csv(file.path(basic_path,"Performance_Scores/Task_Performance_Scores.csv")) # contains overall accuracy
data_pat_pre <- read.csv(file.path(basic_path,"Data_Patients_Pre.csv"))
data_pat_pre_clean <- data_pat_pre %>%
filter(!is.na(Response)) # equals to NA at T1_BAT_FAS_score and/or T3_BAT_FAS_score
features_df <- left_join(x = data_pat_pre_clean,
y = task_data %>% select(Subject, NumbLet_Average_PC,
Stroop_Average_PC,
TwoBack_Average_PC),
by = "Subject")
labels_df <- features_df["Response"]
features_df$Response <- NULL
outcome_df <- data.frame(FAS_perc_change = ((features_df$T3_BAT_FAS_score - features_df$T1_BAT_FAS_score) / features_df$T1_BAT_FAS_score) * 100)
View(outcome_df)
View(outcome_df)
# 1. OneHot-Encoding of variable "Abschluss"
features_df$Abschluss <- as.character(features_df$Abschluss)
dummy <- dummyVars(" ~ Abschluss", data = features_df)
trsf <- data.frame(predict(dummy, newdata = features_df, fullRank=TRUE))
features_df_enc <- cbind(features_df, trsf)
# 2. Drop variables "Abschluss", "Subject", "Gruppe", and "T3_BAT_FAS_score"
features_df_enc$Subject <- NULL
features_df_enc$Gruppe <- NULL
features_df_enc$Abschluss <- NULL
features_df_enc$T3_BAT_FAS_score <- NULL
# 3. Rename columns
features_df_enc <- features_df_enc %>%
rename(is_woman = Geschlecht,
Age = Alter,
FAS = T1_BAT_FAS_score,
BDI_II = T1_BAT_BDI_II_score,
STAI_T = T1_BAT_STAI_T_score,
BIS_11 = T1_BAT_BIS_11_score,
Kirby_k = T1_BAT_Kirby_k_score,
CFC_14 = T1_BAT_CFC_14_score,
SRHI = T1_BAT_SRHI_score,
Hauptschule = Abschluss1,
Realschule = Abschluss2,
Abitur = Abschluss3,
anderer_Abschluss = Abschluss4)
#var_category <- find_bin_cols(features_df_enc_clean)
# TEST
bin_cols <- c("is_woman", "Hauptschule", "Realschule", "Abitur", "anderer_Abschluss")
non_bin_cols <- setdiff(names(features_df_enc), bin_cols)
# TODO: Replace bin_cols with var_category$binary and non_bin_cols with var_category$non_binary as soon as function find_bin_cols works
for (feature in bin_cols) {
features_df_enc[[feature]][is.na(features_df_enc[[feature]])] <- 77777
}
for (feature in non_bin_cols) {
features_df_enc[[feature]][is.na(features_df_enc[[feature]])] <- 99999
}
clin_features <- c("is_woman", "Age", "FAS", "BDI_II", "STAI_T", "BIS_11", "Kirby_k", "CFC_14", "SRHI", "Hauptschule", "Realschule", "Abitur", "anderer_Abschluss")
clin_features_df_enc <- features_df_enc[clin_features]
file_path <- "Z:/Projekte_Meinke/Old_projects/Labrotation_Rebecca/Feature_Label_Dataframes/"
write.csv(features_df_enc, paste0(file_path, "Features.csv"), row.names = FALSE)
write.csv(clin_features_df_enc, paste0(file_path, "Clinical_Features.csv"), row.names = FALSE)
write.csv(labels_df, paste0(file_path, "Labels.csv"), row.names = FALSE)
write.csv(outcome_df, paste0(file_path, "Outcome.csv"), row.names = FALSE)
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE,rows.print = 6, cols.min.print = 3)
library(dplyr)
library(tidyverse)
library(caret)
basic_path <- "Z:/Projekte_Meinke/Old_projects/Labrotation_Rebecca/Daten_Gruppenvergleich/With_wrong_responses"
task_data <- read.csv(file.path(basic_path,"Performance_Scores/Task_Performance_Scores.csv")) # contains overall accuracy
basic_path <- "Z:/Projekte_Meinke/Old_projects/Labrotation_Rebecca/0_Datapreparation/Daten_Gruppenvergleich/With_wrong_responses"
task_data <- read.csv(file.path(basic_path,"Performance_Scores/Task_Performance_Scores.csv")) # contains overall accuracy
data_pat_pre <- read.csv(file.path(basic_path,"Data_Patients_Pre.csv"))
data_pat_pre_clean <- data_pat_pre %>%
filter(!is.na(Response)) # equals to NA at T1_BAT_FAS_score and/or T3_BAT_FAS_score
features_df <- left_join(x = data_pat_pre_clean,
y = task_data %>% select(Subject, NumbLet_Average_PC,
Stroop_Average_PC,
TwoBack_Average_PC),
by = "Subject")
labels_df <- features_df["Response"]
features_df$Response <- NULL
outcome_df <- data.frame(FAS_perc_change = ((features_df$T3_BAT_FAS_score - features_df$T1_BAT_FAS_score) / features_df$T1_BAT_FAS_score) * 100)
# 1. OneHot-Encoding of variable "Abschluss"
features_df$Abschluss <- as.character(features_df$Abschluss)
dummy <- dummyVars(" ~ Abschluss", data = features_df)
trsf <- data.frame(predict(dummy, newdata = features_df, fullRank=TRUE))
features_df_enc <- cbind(features_df, trsf)
# 2. Drop variables "Abschluss", "Subject", "Gruppe", and "T3_BAT_FAS_score"
features_df_enc$Subject <- NULL
features_df_enc$Gruppe <- NULL
features_df_enc$Abschluss <- NULL
features_df_enc$T3_BAT_FAS_score <- NULL
# 3. Rename columns
features_df_enc <- features_df_enc %>%
rename(is_woman = Geschlecht,
Age = Alter,
FAS = T1_BAT_FAS_score,
BDI_II = T1_BAT_BDI_II_score,
STAI_T = T1_BAT_STAI_T_score,
BIS_11 = T1_BAT_BIS_11_score,
Kirby_k = T1_BAT_Kirby_k_score,
CFC_14 = T1_BAT_CFC_14_score,
SRHI = T1_BAT_SRHI_score,
Hauptschule = Abschluss1,
Realschule = Abschluss2,
Abitur = Abschluss3,
anderer_Abschluss = Abschluss4)
#var_category <- find_bin_cols(features_df_enc_clean)
# TEST
bin_cols <- c("is_woman", "Hauptschule", "Realschule", "Abitur", "anderer_Abschluss")
non_bin_cols <- setdiff(names(features_df_enc), bin_cols)
# TODO: Replace bin_cols with var_category$binary and non_bin_cols with var_category$non_binary as soon as function find_bin_cols works
for (feature in bin_cols) {
features_df_enc[[feature]][is.na(features_df_enc[[feature]])] <- 77777
}
for (feature in non_bin_cols) {
features_df_enc[[feature]][is.na(features_df_enc[[feature]])] <- 99999
}
clin_features <- c("is_woman", "Age", "FAS", "BDI_II", "STAI_T", "BIS_11", "Kirby_k", "CFC_14", "SRHI", "Hauptschule", "Realschule", "Abitur", "anderer_Abschluss")
clin_features_df_enc <- features_df_enc[clin_features]
file_path <- "Z:/Projekte_Meinke/Old_projects/Labrotation_Rebecca/Feature_Label_Dataframes/"
write.csv(features_df_enc, paste0(file_path, "all_features.csv"), row.names = FALSE)
file_path <- "Z:/Projekte_Meinke/Old_projects/Labrotation_Rebecca/2_Machine_learning/Feature_Label_Dataframes/"
write.csv(features_df_enc, paste0(file_path, "all_features.csv"), row.names = FALSE)
write.csv(clin_features_df_enc, paste0(file_path, "clinical_features_only.csv"), row.names = FALSE)
write.csv(labels_df, paste0(file_path, "labels.csv"), row.names = FALSE)
write.csv(outcome_df, paste0(file_path, "outcomes.csv"), row.names = FALSE)
