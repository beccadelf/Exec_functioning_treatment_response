}
t_test_table_pre_post <- paired_t_test_mult_cols(df_basis = Patients_pre_vs_post_imp, cols = BIS_columns_renamed)
pander(t_test_table_pre_post)
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE,rows.print = 6, cols.min.print = 3)
library(rmatio)
## Function 1: get relevant data from mat-file for a single subject
df_from_matlab <- function(task_name, subject){
file_name = paste("SFB_C5_",subject,"_",task_name,".mat", sep = "")
data_path = file.path(basic_path,file_name)
data <- read.mat(data_path)
# So far, we only need TrialList_Log_ -> it is the combination of TL_ und LogMat
subtask = paste("TrialList_Log_",task_name,sep = "")
task_df <- as.data.frame(rbindlist(data[[subtask]]))
header <- paste(subtask, "Header", sep = "_")
colnames(task_df) <- c(rbindlist(data[[header]])[1,])
return(task_df)
}
basic_path = "Z:/Projekte_Meinke/Old_projects/Labrotation_Rebecca/Rohdaten/Task_battery/Task_battery"
data <- df_from_matlab(task_name = "StopSignal", subject = "1")
data <- df_from_matlab(task_name = "StopSignal", subject = "1")
library(data.table)
data <- df_from_matlab(task_name = "StopSignal", subject = "1")
View(data)
data_red <- data %>%
select(Condition, RT, Accuracy, `Stop-signal delay`)
library(tidyverse)
data_red <- data %>%
select(Condition, RT, Accuracy, `Stop-signal delay`)
View(data_red)
install.packages("SSRTcalc")
library(SSRTcalc)
View(data_red)
data_red$Condition <- ifelse(data_red$Condition == "Go", 0, 1)
View(data_red)
class(data_red$Condition)
class(data_red$RT)
class(data_red$Accuracy)
class(data_red$`Stop-signal delay`)
data_red[] <- lapply(data_red, as.numeric)
class(data_red$RT)
View(data_red)
SSRT <- integration_adaptiveSSD(data, stop_col = "Condition", rt_col = "RT", acc_col = "Accuracy", ssd_col = "Stop-signal delay")
SSRT <- integration_adaptiveSSD(data, stop_col = Condition, rt_col = RT, acc_col = Accuracy, ssd_col = `Stop-signal delay`)
SSRT <- integration_adaptiveSSD(data, stop_col = "Condition", rt_col = "RT", acc_col = "Accuracy", ssd_col = "Stop-signal delay")
class(data_red$Accuracy)
SSRT <- integration_adaptiveSSD(data_red, stop_col = "Condition", rt_col = "RT", acc_col = "Accuracy", ssd_col = "Stop-signal delay")
files <- list.files(basic_path)
sub_first <- gsub("SFB_C5_","",files)
sub_IDs <- sapply(strsplit(sub_first, "_"), function(x) x[1])
subjects <- unique(sub_IDs)
# Delete alt and "" from subjects
subjects <- subjects[subjects != "alt"]
subjects <- subjects[subjects != ""]
# Initialize empty holder dataframe
SSRT_all <- data.frame()
for (subject in subjects) {
data <- df_from_matlab(task_name = "StopSignal", subject = subject)
# Reduce to only relevant variables
data_red <- data %>%
select(Condition, RT, Accuracy, `Stop-signal delay`)
# Recode condition: Go -> 0, Stop -> 1
data_red$Condition <- ifelse(data_red$Condition == "Go", 0, 1)
# Convert all columns to numeric
data_red[] <- lapply(data_red, as.numeric)
# Calculate SSRT
SSRT_value <- integration_adaptiveSSD(data_red, stop_col = "Condition", rt_col = "RT", acc_col = "Accuracy", ssd_col = "Stop-signal delay")
# Append the result to SSRT_all
SSRT_all <- rbind(SSRT_all, data.frame(Subject = subject, SSRT = SSRT_value))
}
View(SSRT_all)
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE,rows.print = 6, cols.min.print = 3)
library(haven)
library(rmatio)
library(DescTools)
library(data.table)
library(tidyverse)
library(caret)
library(SSRTcalc)
library(ggplot2)
########################################
## Function 1: get relevant data from mat-file for a single subject
########################################
df_from_matlab <- function(task_name, subject){
file_name = paste("SFB_C5_",subject,"_",task_name,".mat", sep = "")
data_path = file.path(basic_path,file_name)
data <- read.mat(data_path)
# So far, we only need TrialList_Log_ -> it is the combination of TL_ und LogMat
subtask = paste("TrialList_Log_",task_name,sep = "")
task_df <- as.data.frame(rbindlist(data[[subtask]]))
header <- paste(subtask, "Header", sep = "_")
colnames(task_df) <- c(rbindlist(data[[header]])[1,])
return(task_df)
}
########################################
## Function 2: merge all task-data of all subjects in one dataframe
########################################
combine_df_across_subj <- function(task){
for (subject in subjects){
try({
df <- df_from_matlab(task,subject)
df$subject <- subject
df_all_subj <- rbind(df_all_subj,df)
})
}
return(df_all_subj)
}
########################################
## Function 3: preprocessing and calculation of mean RT and PC
########################################
preprocess_RT_PC <- function(task, subjects){
# Initialize empty holder dataframe
AllData <- data.frame()
# Loop across all participants
for (subject in subjects) {
# Import data
data <- df_from_matlab(task_name = task, subject = subject)
# Bring data NumberLetter and data Stroop to same format
if (task == "NumberLetter"){
colnames(data) <- sub(" ", "_", colnames(data))
data <- data %>%
rename("Condition"="Task_transition")
} else if (task == "Stroop"){
data <- data %>%
rename("Accuracy"="Fehler")
}
# Basic preprocessing
data_red <- data %>%
# Select relevant columns
select(Condition, Response, Accuracy, RT) %>%
# Discard first trial (only applies to NumbLet)
filter(Condition != "NoPreviousTrial")
# Convert RTs & Accuracy to numeric
data_red$RT <- as.numeric(data_red$RT)
data_red$Accuracy <- as.numeric(data_red$Accuracy)
# STEP 1.1.: Processing data for RT analysis
data_RT_clean <- data_red %>%
## Step 1: Change RT to ms
mutate(RT = RT * 1000) %>%
## Step 2: Remove outlier
filter(RT > 150)
# STEP 1.2.: Compute mean RT overall and per condition
overall_RT_mean <- mean(data_RT_clean$RT)
RT_means <- data_RT_clean %>%
group_by(Condition) %>%
summarize_at(vars(RT), mean)
## Transform data from LONG to WIDE format
wideData_RT <- RT_means %>%
pivot_wider(names_from = Condition, values_from = RT)
# STEP 2: Compute proportion correct overall and per condition
overall_PC <- mean(data_red$Accuracy)
PC <- data_red %>%
group_by(Condition) %>%
summarize_at(vars(Accuracy), mean)
## TODO: Convert to percentages?
## Transform data from LONG to WIDE format
wideData_PC <- PC %>%
pivot_wider(names_from = Condition, values_from = Accuracy)
# STEP 3: Merging the two wide dataframe
## Update column names to include the variable identity
colnames(wideData_RT) <- paste(colnames(wideData_RT),"RT", sep="_")
colnames(wideData_PC) <- paste(colnames(wideData_PC),"PC", sep="_")
## Merge dataframes
wideData_merged <- cbind(wideData_RT, wideData_PC)
# STEP 4: Adding extra relevant info
## Add subject ID, overall mean RT and overall PC
wideData_merged$Subject <- subject
wideData_merged$Overall_RT <- overall_RT_mean
wideData_merged$Overall_PC <- overall_PC
## Store the current processed data into holder as a new row
AllData <- rbind(AllData, wideData_merged)
}
return(AllData)
}
# Function 4: calculate mean and SD of RT and PC of healthy subjects
# mean_sd_HC <- function(data_HC){
#   # Calculate mean and sd of RT and PC across all healthy subjects and conditions
#   meanRT_HC <- mean(data_HC$Overall_RT)
#   sdRT_HC <- sd(data_HC$Overall_RT)
#   meanPC_HC <- mean(data_HC$Overall_PC)
#   sdPC_HC <- sd(data_HC$Overall_PC)
#   return(meanRT_HC, sdRT_HC, meanPC_HC, sdPC_HC) # TODO: have to be stored in a list
# }
basic_path = "Z:/Projekte_Meinke/Old_projects/Labrotation_Rebecca/Rohdaten/Task_battery/Task_battery"
# Load data
data_all <- read_dta('Z:/Projekte_Meinke/Old_projects/Labrotation_Rebecca/Rohdaten/CRC_C5_Hilbert/CRC_C5_Hilbert/Data_Kevin_28.07.23.dta')
data_tasks_old <- read_dta('Z:/Projekte_Meinke/Old_projects/Labrotation_Rebecca/Rohdaten/CRC_C5_Hilbert/CRC_C5_Hilbert/TaskBattery.dta')
data_all_red <- data_all %>%
rename(Subject = id) %>%
select(Subject, Gruppe, T1_BAT_FAS_score, T3_BAT_FAS_score)
# Rename stid for later merge
data_tasks_old <- data_tasks_old %>%
rename(Subject = stid)
AllData_NumbLet <- preprocess_RT_PC(task = "NumberLetter", subjects = subjects)
files <- list.files(basic_path)
sub_first <- gsub("SFB_C5_","",files)
sub_IDs <- sapply(strsplit(sub_first, "_"), function(x) x[1])
subjects <- unique(sub_IDs)
# Delete alt and "" from subjects
subjects <- subjects[subjects != "alt"]
subjects <- subjects[subjects != ""]
AllData_NumbLet <- preprocess_RT_PC(task = "NumberLetter", subjects = subjects)
AllData_Stroop <- preprocess_RT_PC(task = "Stroop", subjects = subjects)
AllData_TwoBack <- preprocess_RT_PC(task = "TwoBack", subjects = subjects)
# Initialize empty holder dataframe
AllData_SST <- data.frame()
for (subject in subjects) {
data_SST <- df_from_matlab(task_name = "StopSignal", subject = subject)
# Reduce to only relevant variables
data_SST_red <- data_SST %>%
select(Condition, RT, Accuracy, `Stop-signal delay`)
# Recode condition: Go -> 0, Stop -> 1
data_SST_red$Condition <- ifelse(data_SST_red$Condition == "Go", 0, 1)
# Convert all columns to numeric
data_SST_red[] <- lapply(data_SST_red, as.numeric)
# Calculate SSRT
SSRT_value <- integration_adaptiveSSD(data_SST_red, stop_col = "Condition", rt_col = "RT",
acc_col = "Accuracy", ssd_col = "Stop-signal delay")
# Append the result to SSRT_all
AllData_SST <- rbind(AllData_SST, data.frame(Subject = subject, SSRT = SSRT_value))
}
View(AllData_SST)
# Align data types
data_all_red$Subject <- as.character(data_all_red$Subject)
merged_data <- AllData_NumbLet %>%
# 1. Merge all task dataframes
left_join(AllData_Stroop, by = "Subject") %>%
left_join(AllData_TwoBack, by = "Subject") %>%
left_join(AllData_SST, by = "Subject") %>%
# 2. Add data_all_red
left_join(data_all_red, by = "Subject")
# TODO: change variable names
View(merged_data)
View(AllData_Stroop)
View(AllData_NumbLet)
View(AllData_NumbLet)
merged_data <- merged_data %>%
rename(NumbLet_Average_RT = Overall_RT.x,
NumbLet_Average_PC = Overall_PC.x,
Stroop_Average_RT = Overall_RT.y,
Stroop_Average_PC = Overall_PC.y,
TwoBack_Average_RT = Overall_RT,
TwoBack_Average_PC = Overall_PC)
View(merged_data)
merged_data <- merged_data %>%
mutate(Gruppe = ifelse(Subject >= 216601 & Subject <= 216760, 2, Gruppe))
View(merged_data)
merged_data_excl1 <- merged_data %>%
filter(!is.na(Gruppe))
excl_group <- anti_join(merged_data, merged_data_excl1, by = "Subject")
View(excl_group)
View(data_all_red)
View(AllData_NumbLet)
merged_data <- merged_data %>%
mutate(Subject = as.numeric(Subject),
Gruppe = ifelse(Subject >= 216601 & Subject <= 216760, 2, Gruppe))
merged_data_excl1 <- merged_data %>%
filter(!is.na(Gruppe))
excl_group <- anti_join(merged_data, merged_data_excl1, by = "Subject")
View(merged_data_excl1)
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE,rows.print = 6, cols.min.print = 3)
library(haven)
library(rmatio)
library(DescTools)
library(data.table)
library(tidyverse)
library(caret)
library(SSRTcalc)
library(ggplot2)
########################################
## Function 1: get relevant data from mat-file for a single subject
########################################
df_from_matlab <- function(task_name, subject){
file_name = paste("SFB_C5_",subject,"_",task_name,".mat", sep = "")
data_path = file.path(basic_path,file_name)
data <- read.mat(data_path)
# So far, we only need TrialList_Log_ -> it is the combination of TL_ und LogMat
subtask = paste("TrialList_Log_",task_name,sep = "")
task_df <- as.data.frame(rbindlist(data[[subtask]]))
header <- paste(subtask, "Header", sep = "_")
colnames(task_df) <- c(rbindlist(data[[header]])[1,])
return(task_df)
}
########################################
## Function 2: merge all task-data of all subjects in one dataframe
########################################
combine_df_across_subj <- function(task){
for (subject in subjects){
try({
df <- df_from_matlab(task,subject)
df$subject <- subject
df_all_subj <- rbind(df_all_subj,df)
})
}
return(df_all_subj)
}
########################################
## Function 3: preprocessing and calculation of mean RT and PC
########################################
preprocess_RT_PC <- function(task, subjects){
# Initialize empty holder dataframe
AllData <- data.frame()
# Loop across all participants
for (subject in subjects) {
# Import data
data <- df_from_matlab(task_name = task, subject = subject)
# Bring data NumberLetter and data Stroop to same format
if (task == "NumberLetter"){
colnames(data) <- sub(" ", "_", colnames(data))
data <- data %>%
rename("Condition"="Task_transition")
} else if (task == "Stroop"){
data <- data %>%
rename("Accuracy"="Fehler")
}
# Basic preprocessing
data_red <- data %>%
# Select relevant columns
select(Condition, Response, Accuracy, RT) %>%
# Discard first trial (only applies to NumbLet)
filter(Condition != "NoPreviousTrial")
# Convert RTs & Accuracy to numeric
data_red$RT <- as.numeric(data_red$RT)
data_red$Accuracy <- as.numeric(data_red$Accuracy)
# STEP 1.1.: Processing data for RT analysis
data_RT_clean <- data_red %>%
## Step 1: Change RT to ms
mutate(RT = RT * 1000) %>%
## Step 2: Remove outlier
filter(RT > 150)
# STEP 1.2.: Compute mean RT overall and per condition
overall_RT_mean <- mean(data_RT_clean$RT)
RT_means <- data_RT_clean %>%
group_by(Condition) %>%
summarize_at(vars(RT), mean)
## Transform data from LONG to WIDE format
wideData_RT <- RT_means %>%
pivot_wider(names_from = Condition, values_from = RT)
# STEP 2: Compute proportion correct overall and per condition
overall_PC <- mean(data_red$Accuracy)
PC <- data_red %>%
group_by(Condition) %>%
summarize_at(vars(Accuracy), mean)
## TODO: Convert to percentages?
## Transform data from LONG to WIDE format
wideData_PC <- PC %>%
pivot_wider(names_from = Condition, values_from = Accuracy)
# STEP 3: Merging the two wide dataframe
## Update column names to include the variable identity
colnames(wideData_RT) <- paste(colnames(wideData_RT),"RT", sep="_")
colnames(wideData_PC) <- paste(colnames(wideData_PC),"PC", sep="_")
## Merge dataframes
wideData_merged <- cbind(wideData_RT, wideData_PC)
# STEP 4: Adding extra relevant info
## Add subject ID, overall mean RT and overall PC
wideData_merged$Subject <- subject
wideData_merged$Overall_RT <- overall_RT_mean
wideData_merged$Overall_PC <- overall_PC
## Store the current processed data into holder as a new row
AllData <- rbind(AllData, wideData_merged)
}
return(AllData)
}
# Function 4: calculate mean and SD of RT and PC of healthy subjects
# mean_sd_HC <- function(data_HC){
#   # Calculate mean and sd of RT and PC across all healthy subjects and conditions
#   meanRT_HC <- mean(data_HC$Overall_RT)
#   sdRT_HC <- sd(data_HC$Overall_RT)
#   meanPC_HC <- mean(data_HC$Overall_PC)
#   sdPC_HC <- sd(data_HC$Overall_PC)
#   return(meanRT_HC, sdRT_HC, meanPC_HC, sdPC_HC) # TODO: have to be stored in a list
# }
basic_path = "Z:/Projekte_Meinke/Old_projects/Labrotation_Rebecca/Rohdaten/Task_battery/Task_battery"
# Load data
data_all <- read_dta('Z:/Projekte_Meinke/Old_projects/Labrotation_Rebecca/Rohdaten/CRC_C5_Hilbert/CRC_C5_Hilbert/Data_Kevin_28.07.23.dta')
data_tasks_old <- read_dta('Z:/Projekte_Meinke/Old_projects/Labrotation_Rebecca/Rohdaten/CRC_C5_Hilbert/CRC_C5_Hilbert/TaskBattery.dta')
data_all_red <- data_all %>%
rename(Subject = id) %>%
select(Subject, Gruppe, T1_BAT_FAS_score, T3_BAT_FAS_score)
# Rename stid for later merge
data_tasks_old <- data_tasks_old %>%
rename(Subject = stid)
files <- list.files(basic_path)
sub_first <- gsub("SFB_C5_","",files)
sub_IDs <- sapply(strsplit(sub_first, "_"), function(x) x[1])
subjects <- unique(sub_IDs)
# Delete alt and "" from subjects
subjects <- subjects[subjects != "alt"]
subjects <- subjects[subjects != ""]
AllData_NumbLet <- preprocess_RT_PC(task = "NumberLetter", subjects = subjects)
AllData_Stroop <- preprocess_RT_PC(task = "Stroop", subjects = subjects)
AllData_TwoBack <- preprocess_RT_PC(task = "TwoBack", subjects = subjects)
# Initialize empty holder dataframe
AllData_SST <- data.frame()
for (subject in subjects) {
data_SST <- df_from_matlab(task_name = "StopSignal", subject = subject)
# Reduce to only relevant variables
data_SST_red <- data_SST %>%
select(Condition, RT, Accuracy, `Stop-signal delay`)
# Recode condition: Go -> 0, Stop -> 1
data_SST_red$Condition <- ifelse(data_SST_red$Condition == "Go", 0, 1)
# Convert all columns to numeric
data_SST_red[] <- lapply(data_SST_red, as.numeric)
# Calculate SSRT
SSRT_value <- integration_adaptiveSSD(data_SST_red, stop_col = "Condition", rt_col = "RT",
acc_col = "Accuracy", ssd_col = "Stop-signal delay")
# Append the result to SSRT_all
AllData_SST <- rbind(AllData_SST, data.frame(Subject = subject, SSRT = SSRT_value))
}
# Align data types
data_all_red$Subject <- as.character(data_all_red$Subject)
merged_data <- AllData_NumbLet %>%
# 1. Merge all task dataframes
left_join(AllData_Stroop, by = "Subject") %>%
left_join(AllData_TwoBack, by = "Subject") %>%
left_join(AllData_SST, by = "Subject") %>%
# 2. Add data_all_red
left_join(data_all_red, by = "Subject")
# Change variable names
merged_data <- merged_data %>%
rename(NumbLet_Average_RT = Overall_RT.x,
NumbLet_Average_PC = Overall_PC.x,
Stroop_Average_RT = Overall_RT.y,
Stroop_Average_PC = Overall_PC.y,
TwoBack_Average_RT = Overall_RT,
TwoBack_Average_PC = Overall_PC)
# Assign post IDs (Gruppe = 2) # TODO: IDs 2166108, 2166120, 2166121, 2166321 get assigned a 2
merged_data <- merged_data %>%
mutate(Subject = as.numeric(Subject),
Gruppe = ifelse(Subject >= 216601 & Subject <= 216760, 2, Gruppe))
merged_data_excl1 <- merged_data %>%
filter(!is.na(Gruppe))
excl_group <- anti_join(merged_data, merged_data_excl1, by = "Subject")
View(excl_group)
merged_data_clean <- merged_data_excl1 %>%
filter(Gruppe == 0 | Gruppe == 2 | (Gruppe == 1 & !is.na(T1_BAT_FAS_score) & !is.na(T3_BAT_FAS_score)))
excl_criterion <- anti_join(merged_data_excl1, merged_data_clean, by = "Subject")
View(merged_data_clean)
## Step 1: Calculate mean and SD for RT and PC across all healthy subjects and all conditions
NumbLet_mean_sd_HC <- merged_data_clean %>%
filter(Gruppe == 0) %>%
select(NumbLet_Average_RT, NumbLet_Average_PC) %>%
summarise(meanRT = mean(NumbLet_Average_RT),
meanPC = mean(NumbLet_Average_PC),
sdRT = sd(NumbLet_Average_RT),
sdPC = sd(NumbLet_Average_PC))
## Step 2: Standardize RT and PC for each condition
merged_data_clean <- merged_data_clean %>%
mutate(Z_Repeat_RT = (Repeat_RT - NumbLet_mean_sd_HC$meanRT) / NumbLet_mean_sd_HC$sdRT,
Z_Switch_RT = (Switch_RT - NumbLet_mean_sd_HC$meanRT) / NumbLet_mean_sd_HC$sdRT,
Z_Repeat_PC = (Repeat_PC - NumbLet_mean_sd_HC$meanPC) / NumbLet_mean_sd_HC$sdPC,
Z_Switch_PC = (Switch_PC - NumbLet_mean_sd_HC$meanPC) / NumbLet_mean_sd_HC$sdPC)
# Step 3: Calculate BIS(Repeat), BIS(Switch) and Difference Score
merged_data_clean <- merged_data_clean %>%
mutate(NumberLetter_BIS_Repeat = Z_Repeat_PC - Z_Repeat_RT,
NumberLetter_BIS_Switch = Z_Switch_PC - Z_Switch_RT) %>%
mutate(NumberLetter_Diff_Score = BIS_Switch - BIS_Repeat)
merged_data_clean <- merged_data_clean %>%
mutate(NumberLetter_BIS_Repeat = Z_Repeat_PC - Z_Repeat_RT,
NumberLetter_BIS_Switch = Z_Switch_PC - Z_Switch_RT) %>%
mutate(NumberLetter_Diff_Score = NumberLetter_BIS_Switch - NumberLetter_BIS_Repeat)
## Step 1: Calculate mean and SD for RT and PC across all healthy subjects and all conditions
Stroop_mean_sd_HC <- merged_data_clean %>%
filter(Gruppe == 0) %>%
select(Stroop_Average_RT, Stroop_Average_PC) %>%
summarise(meanRT = mean(Stroop_Average_RT),
meanPC = mean(Stroop_Average_PC),
sdRT = sd(Stroop_Average_RT),
sdPC = sd(Stroop_Average_PC))
## Step 2: Standardize RT and PC for each condition
merged_data_clean <- merged_data_clean %>%
mutate(Z_Congruent_RT = (Congruent_RT - Stroop_mean_sd_HC$meanRT) / Stroop_mean_sd_HC$sdRT,
Z_Incongruent_RT = (Incongruent_RT - Stroop_mean_sd_HC$meanRT) / Stroop_mean_sd_HC$sdRT,
Z_Congruent_PC = (Congruent_PC - Stroop_mean_sd_HC$meanPC) / Stroop_mean_sd_HC$sdPC,
Z_Incongruent_PC = (Incongruent_PC - Stroop_mean_sd_HC$meanPC) / Stroop_mean_sd_HC$sdPC)
# Step 3: Calculate BIS(Congruent), BIS(Incongruent) and Difference Score
merged_data_clean <- merged_data_clean %>%
mutate(Stroop_BIS_Congruent = Z_Congruent_PC - Z_Congruent_RT,
Stroop_BIS_Incongruent = Z_Incongruent_PC - Z_Incongruent_RT) %>%
mutate(Stroop_Diff_Score = Stroop_BIS_Incongruent - Stroop_BIS_Congruent)
## Step 1: Calculate mean and SD for RT and PC across all healthy subjects and all conditions
TwoBack_mean_sd_HC <- merged_data_clean %>%
filter(Gruppe == 0) %>%
select(TwoBack_Average_RT, TwoBack_Average_PC) %>%
summarise(meanRT = mean(TwoBack_Average_RT),
meanPC = mean(TwoBack_Average_PC),
sdRT = sd(TwoBack_Average_RT),
sdPC = sd(TwoBack_Average_PC))
## Step 2: Standardize RT and PC for each condition
merged_data_clean <- merged_data_clean %>%
mutate(Z_Total_RT = (TwoBack_Average_RT - TwoBack_mean_sd_HC$meanRT) / TwoBack_mean_sd_HC$sdRT,
Z_Target_RT = (Target_RT - TwoBack_mean_sd_HC$meanRT) / TwoBack_mean_sd_HC$sdRT,
Z_Foil_RT = (Foil_RT - TwoBack_mean_sd_HC$meanRT) / TwoBack_mean_sd_HC$sdRT,
Z_Total_PC = (TwoBack_Average_PC - TwoBack_mean_sd_HC$meanPC) / TwoBack_mean_sd_HC$sdPC,
Z_Target_PC = (Target_PC - TwoBack_mean_sd_HC$meanPC) / TwoBack_mean_sd_HC$sdPC,
Z_Foil_PC = (Foil_PC - TwoBack_mean_sd_HC$meanPC) / TwoBack_mean_sd_HC$sdPC)
# Calculate BIS(Target), BIS(Total) and BIS_Foil
merged_data_clean <- merged_data_clean %>%
mutate(TwoBack_BIS_Total = Z_Total_PC - Z_Total_RT,
TwoBack_BIS_Target = Z_Target_PC - Z_Target_RT,
TwoBack_BIS_Foil = Z_Foil_PC - Z_Foil_RT)
split_df <- split(merged_data_clean, merged_data_clean$Gruppe)
data_HC <- split_df$"0"
data_Pat_pre <- split_df$"1"
data_Pat_post <- split_df$"2"
file_path <- "Z:/Projekte_Meinke/Old_projects/Labrotation_Rebecca/Daten_Gruppenvergleich/With_wrong_responses/"
# Write data to CSV using the function
write.csv(data_HC, paste0(base_path, "Data_HC.csv"), row.names = FALSE)
file_path <- "Z:/Projekte_Meinke/Old_projects/Labrotation_Rebecca/Daten_Gruppenvergleich/With_wrong_responses/"
# Write data to CSV using the function
write.csv(data_HC, paste0(file_path, "Data_HC.csv"), row.names = FALSE)
write.csv(data_Pat_pre, paste0(file_path, "Data_Patients_Pre.csv"), row.names = FALSE)
write.csv(data_Pat_post, paste0(file_path, "Data_Patients_Post.csv"), row.names = FALSE)
