y = data_all_red,
by = "Subject")
}
AllData_NumbLet_merged <- result_dfs[[1]]
AllData_Stroop_merged <- result_dfs[[2]]
AllData_TwoBack_merged <- result_dfs[[3]]
View(AllData_NumbLet_merged)
View(AllData_Stroop_merged)
View(AllData_TwoBack_merged)
View(AllData_NumbLet)
View(AllData_NumbLet_merged)
# NumberLetter
AllData_NumbLet_merged <- AllData_NumbLet_merged %>%
mutate(Gruppe = ifelse(Subject >= 216601 & Subject <= 216760, 2, Gruppe))
# Stroop
AllData_Stroop_merged <- AllData_Stroop_merged %>%
mutate(Gruppe = ifelse(Subject >= 216601 & Subject <= 216760, 2, Gruppe))
# TwoBack
AllData_TwoBack_merged <- AllData_TwoBack_merged %>%
mutate(Gruppe = ifelse(Subject >= 216601 & Subject <= 216760, 2, Gruppe))
# Remove subjects with missing group information
AllData_NumbLet_clean.1 <- AllData_NumbLet_merged %>%
filter(!is.na(Gruppe))
excl_subs_NL_group <- anti_join(AllData_NumbLet_merged, AllData_NumbLet_clean.1, by = "Subject")
# Remove patients with missing FAS_T1 and/or FAS_T3
AllData_NumbLet_clean.2 <- AllData_NumbLet_clean.1 %>%
filter(Gruppe == 0 | Gruppe == 2 | (Gruppe == 1 & !is.na(T1_BAT_FAS_score) & !is.na(T3_BAT_FAS_score)))
excl_subs_NL_rc <- anti_join(AllData_NumbLet_clean.1, AllData_NumbLet_clean.2, by = "Subject")
# Remove subjects that have NAs in all 4 task variables
# AllData_NumbLet_clean.3 <- AllData_NumbLet_clean.2 %>%
#   filter(!all(is.na(Repeat_RT), is.na(Switch_RT), is.na(Repeat_PC), is.na(Switch_PC)))
# excl_subs_NL_task <- anti_join(AllData_NumbLet_clean.2, AllData_NumbLet_clean.3, by = "Subject")
# Remove subjects with missing group information
AllData_Stroop_clean.1 <- AllData_Stroop_merged %>%
filter(!is.na(Gruppe))
excl_subs_Str_group <- anti_join(AllData_Stroop_merged, AllData_Stroop_clean.1, by = "Subject")
# Remove patients with missing FAS_T1 and/or FAS_T3
AllData_Stroop_clean.2 <- AllData_Stroop_clean.1 %>%
filter(Gruppe == 0 | Gruppe == 2 | (Gruppe == 1 & !is.na(T1_BAT_FAS_score) & !is.na(T3_BAT_FAS_score)))
excl_subs_Str_rc <- anti_join(AllData_Stroop_clean.1, AllData_Stroop_clean.2, by = "Subject")
# Remove subjects that have NAs in all 4 task variables
# AllData_Stroop_clean.3 <- AllData_Stroop_clean.2 %>%
#   filter(!all(is.na(Congruent_RT), is.na(Incongruent_RT), is.na(Congruent_PC), is.na(Incongruent_PC)))
# excl_subs_Str_task <- anti_join(AllData_Stroop_clean.2, AllData_Stroop_clean.3, by = "Subject")
# Remove subjects with missing group information
AllData_TwoBack_clean.1 <- AllData_TwoBack_merged %>%
filter(!is.na(Gruppe))
excl_subs_2B_group <- anti_join(AllData_TwoBack_merged, AllData_TwoBack_clean.1, by = "Subject")
# Remove patients with missing FAS_T1 and/or FAS_T3
AllData_TwoBack_clean.2 <- AllData_TwoBack_clean.1 %>%
filter(Gruppe == 0 | Gruppe == 2 | (Gruppe == 1 & !is.na(T1_BAT_FAS_score) & !is.na(T3_BAT_FAS_score)))
excl_subs_2B_rc <- anti_join(AllData_TwoBack_clean.1, AllData_TwoBack_clean.2, by = "Subject")
# Remove subjects that have NAs in all 4 task variables
# AllData_TwoBack_clean.3 <- AllData_TwoBack_clean.2 %>%
#   filter(!all(is.na(Foil_RT), is.na(Target_RT), is.na(Foil_PC), is.na(Target_PC)))
# excl_subs_2B_task <- anti_join(AllData_TwoBack_clean.2, AllData_TwoBack_clean.3, by = "Subject")
## Step 1: Calculate mean and SD for RT and PC across all healthy subjects and all conditions
mean_sd_HC_NumbLet <- AllData_NumbLet_clean.2 %>%
filter(Gruppe == 0) %>%
select(Overall_RT, Overall_PC) %>%
summarise(meanRT = mean(Overall_RT),
meanPC = mean(Overall_PC),
sdRT = sd(Overall_RT),
sdPC = sd(Overall_PC))
## Step 2: Standardize RT and PC for each condition
AllData_NumbLet_clean.2 <- AllData_NumbLet_clean.2 %>%
mutate(Z_Repeat_RT = (Repeat_RT - mean_sd_HC_NumbLet$meanRT) / mean_sd_HC_NumbLet$sdRT,
Z_Switch_RT = (Switch_RT - mean_sd_HC_NumbLet$meanRT) / mean_sd_HC_NumbLet$sdRT,
Z_Repeat_PC = (Repeat_PC - mean_sd_HC_NumbLet$meanPC) / mean_sd_HC_NumbLet$sdPC,
Z_Switch_PC = (Switch_PC - mean_sd_HC_NumbLet$meanPC) / mean_sd_HC_NumbLet$sdPC)
# Step 3: Calculate BIS(Repeat), BIS(Switch) and Difference Score
AllData_NumbLet_clean.2 <- AllData_NumbLet_clean.2 %>%
mutate(BIS_Repeat = Z_Repeat_PC - Z_Repeat_RT,
BIS_Switch = Z_Switch_PC - Z_Switch_RT) %>%
mutate(Diff_Score_NumbLet = BIS_Switch - BIS_Repeat)
View(AllData_NumbLet_clean.2)
## Step 1: Calculate mean and SD for RT and PC across all healthy subjects and all conditions
mean_sd_HC_Stroop <- AllData_Stroop_clean.2 %>%
filter(Gruppe == 0) %>%
select(Overall_RT, Overall_PC) %>%
summarise(meanRT = mean(Overall_RT),
meanPC = mean(Overall_PC),
sdRT = sd(Overall_RT),
sdPC = sd(Overall_PC))
## Step 2: Standardize RT and PC for each condition
AllData_Stroop_clean.2 <- AllData_Stroop_clean.2 %>%
mutate(Z_Congruent_RT = (Congruent_RT - mean_sd_HC_Stroop$meanRT) / mean_sd_HC_Stroop$sdRT,
Z_Incongruent_RT = (Incongruent_RT - mean_sd_HC_Stroop$meanRT) / mean_sd_HC_Stroop$sdRT,
Z_Congruent_PC = (Congruent_PC - mean_sd_HC_Stroop$meanPC) / mean_sd_HC_Stroop$sdPC,
Z_Incongruent_PC = (Incongruent_PC - mean_sd_HC_Stroop$meanPC) / mean_sd_HC_Stroop$sdPC)
# Step 3: Calculate BIS(Congruent), BIS(Incongruent) and Difference Score
AllData_Stroop_clean.2 <- AllData_Stroop_clean.2 %>%
mutate(BIS_Congruent = Z_Congruent_PC - Z_Congruent_RT,
BIS_Incongruent = Z_Incongruent_PC - Z_Incongruent_RT) %>%
mutate(Diff_Score_Stroop = BIS_Incongruent - BIS_Congruent)
## Step 1: Calculate mean and SD for RT and PC across all healthy subjects and all conditions
mean_sd_HC_TwoBack <- AllData_TwoBack_clean.2 %>%
filter(Gruppe == 0) %>%
select(Overall_RT, Overall_PC) %>%
summarise(meanRT = mean(Overall_RT),
meanPC = mean(Overall_PC),
sdRT = sd(Overall_RT),
sdPC = sd(Overall_PC))
## Step 2: Standardize RT and PC for each condition
AllData_TwoBack_clean.2 <- AllData_TwoBack_clean.2 %>%
mutate(Z_Total_RT = (Overall_RT - mean_sd_HC_TwoBack$meanRT) / mean_sd_HC_TwoBack$sdRT,
Z_Target_RT = (Target_RT - mean_sd_HC_TwoBack$meanRT) / mean_sd_HC_TwoBack$sdRT,
Z_Foil_RT = (Foil_RT - mean_sd_HC_TwoBack$meanRT) / mean_sd_HC_TwoBack$sdRT,
Z_Total_PC = (Overall_PC - mean_sd_HC_TwoBack$meanPC) / mean_sd_HC_TwoBack$sdPC,
Z_Target_PC = (Target_PC - mean_sd_HC_TwoBack$meanPC) / mean_sd_HC_TwoBack$sdPC,
Z_Foil_PC = (Foil_PC - mean_sd_HC_TwoBack$meanPC) / mean_sd_HC_TwoBack$sdPC)
# Calculate BIS(Target), BIS(Total) and BIS_Foil
AllData_TwoBack_clean.2 <- AllData_TwoBack_clean.2 %>%
mutate(BIS_Total = Z_Total_PC - Z_Total_RT,
BIS_Target = Z_Target_PC - Z_Target_RT,
BIS_Foil = Z_Foil_PC - Z_Foil_RT)
# NumberLetter
split_df_NumbLet <- split(AllData_NumbLet_clean.2, AllData_NumbLet_clean.2$Gruppe)
data_NumbLet_HC <- split_df_NumbLet$"0"
data_NumbLet_Pat_pre <- split_df_NumbLet$"1"
data_NumbLet_Pat_post <- split_df_NumbLet$"2"
# Stroop
split_df_Stroop <- split(AllData_Stroop_clean.2, AllData_Stroop_clean.2$Gruppe)
data_Stroop_HC <- split_df_Stroop$"0"
data_Stroop_Pat_pre <- split_df_Stroop$"1"
data_Stroop_Pat_post <- split_df_Stroop$"2"
# TwoBack
split_df_TwoBack <- split(AllData_TwoBack_clean.2, AllData_TwoBack_clean.2$Gruppe)
data_TwoBack_HC <- split_df_TwoBack$"0"
data_TwoBack_Pat_pre <- split_df_TwoBack$"1"
data_TwoBack_Pat_post <- split_df_TwoBack$"2"
# define function
write_data_to_csv <- function(data, filename) {
base_path <- "Z:/Projekte_Meinke/Old_projects/Labrotation_Rebecca/Daten_Gruppenvergleich/With_wrong_responses/"
write.csv(data, paste0(base_path, filename), row.names = FALSE)
}
# Write data to CSV using the function
write_data_to_csv(data_NumbLet_HC, "NumberLetter_HC.csv")
write_data_to_csv(data_NumbLet_Pat_pre, "NumberLetter_Patients_Pre.csv")
write_data_to_csv(data_NumbLet_Pat_post, "NumberLetter_Patients_Post.csv")
write_data_to_csv(data_Stroop_HC, "Stroop_HC.csv")
write_data_to_csv(data_Stroop_Pat_pre, "Stroop_Patients_Pre.csv")
write_data_to_csv(data_Stroop_Pat_post, "Stroop_Patients_Post.csv")
write_data_to_csv(data_TwoBack_HC, "TwoBack_HC.csv")
write_data_to_csv(data_TwoBack_Pat_pre, "TwoBack_Patients_Pre.csv")
write_data_to_csv(data_TwoBack_Pat_post, "TwoBack_Patients_Post.csv")
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(dplyr)
library(tidyr)
library(pander)
library(effsize)
library(pwr)
library(gtsummary)
NumberLetter_HC <- read.csv("Z:/Projekte_Meinke/Old_projects/Labrotation_Rebecca/Daten_Gruppenvergleich/With_wrong_responses/NumberLetter_HC.csv")
NumberLetter_Patients_Post <- read.csv("Z:/Projekte_Meinke/Old_projects/Labrotation_Rebecca/Daten_Gruppenvergleich/With_wrong_responses/NumberLetter_Patients_Post.csv")
NumberLetter_Patients_Pre <-  read.csv("Z:/Projekte_Meinke/Old_projects/Labrotation_Rebecca/Daten_Gruppenvergleich/With_wrong_responses/NumberLetter_Patients_Pre.csv")
Stroop_HC <- read.csv("Z:/Projekte_Meinke/Old_projects/Labrotation_Rebecca/Daten_Gruppenvergleich/With_wrong_responses/Stroop_HC.csv")
Stroop_Patients_Post <-  read.csv("Z:/Projekte_Meinke/Old_projects/Labrotation_Rebecca/Daten_Gruppenvergleich/With_wrong_responses/Stroop_Patients_Post.csv")
Stroop_Patients_Pre <-  read.csv("Z:/Projekte_Meinke/Old_projects/Labrotation_Rebecca/Daten_Gruppenvergleich/With_wrong_responses/Stroop_Patients_Pre.csv")
TwoBack_HC <- read.csv("Z:/Projekte_Meinke/Old_projects/Labrotation_Rebecca/Daten_Gruppenvergleich/With_wrong_responses/TwoBack_HC.csv")
TwoBack_Patients_Post <-  read.csv("Z:/Projekte_Meinke/Old_projects/Labrotation_Rebecca/Daten_Gruppenvergleich/With_wrong_responses/TwoBack_Patients_Post.csv")
TwoBack_Patients_Pre <-  read.csv("Z:/Projekte_Meinke/Old_projects/Labrotation_Rebecca/Daten_Gruppenvergleich/With_wrong_responses/TwoBack_Patients_Pre.csv")
data_all <- haven::read_dta('Z:/Projekte_Meinke/Old_projects/Labrotation_Rebecca/CognitiveControl_Treatment/Data_Kevin_28.07.23.dta')
colnames(data_all)[which(colnames(data_all) == "id")] <- "Subject"
# Merge patients and controls
## 1. Merge patients Pre (different tasks)
Patients_pre_2 <- merge(NumberLetter_Patients_Pre, Stroop_Patients_Pre, by = "Subject")
Patients_pre_3 <- merge(Patients_pre_2, TwoBack_Patients_Pre, by = "Subject")
## 2. Merge controls (different tasks)
Controls_2 <- merge(NumberLetter_HC, Stroop_HC, by = "Subject")
Controls_3 <- merge(Controls_2, TwoBack_HC, by = "Subject")
## 3. Merge Controls and patients
Patients_vs_HC <- rbind(Patients_pre_3, Controls_3)
## 4. Reduce dataset to BIS columns
BIS_columns <- colnames(Patients_vs_HC)[startsWith(colnames(Patients_vs_HC), "BIS")]
Patients_vs_HC_imp <- Patients_vs_HC[,c("Subject",BIS_columns,"Gruppe")]
## 5. Add better names
Patients_vs_HC_imp <- Patients_vs_HC_imp %>%
rename(NumberLetter_BIS_Repeat = BIS_Repeat,
NumberLetter_BIS_Switch = BIS_Switch,
Stroop_BIS_Congruent = BIS_Congruent,
Stroop_BIS_Incongruent = BIS_Incongruent,
TwoBack_BIS_Total = BIS_Total,
TwoBack_BIS_Target = BIS_Target,
TwoBack_BIS_Foil = BIS_Foil)
BIS_columns_renamed <- grep("BIS", colnames(Patients_vs_HC_imp), value = TRUE)
## 6. Add confounds (Alter, Geschlecht, Abschluss)
Patients_vs_HC_imp_conf <- merge(data_all[,c("Subject","Alter","Geschlecht","Abschluss")], Patients_vs_HC_imp, by = "Subject")
t_test_mult_cols <- function(df_basis, cols) {
df <- data.frame(t_statistic = numeric(length(cols)), p_value = numeric(length(cols)),
group_mean_Patients = numeric(length(cols)), sd_Patients = numeric(length(cols)),
group_mean_HC = numeric(length(cols)), sd_HC = numeric(length(cols)),
cohen_d = numeric(length(cols)))
rownames(df) <- cols
for (col in cols) {
# Using the non-formula interface
group0 <- df_basis[df_basis[["Gruppe"]] == 0, col]
group1 <- df_basis[df_basis[["Gruppe"]] == 1, col]
results <- t.test(group0, group1, paired = FALSE, var.equal = FALSE)
#Alternativ using formula method:
#results <- t.test(df_basis[[col]] ~ df_basis[["Gruppe"]], paired = FALSE, var.equal = FALSE)
# Calculate Cohen's d using the cohen.d function (effect size)
cohen_d_result <- cohen.d(group0, group1, hedges.correction = FALSE)
cohen_d <- cohen_d_result$estimate
# Calculate power using pwr.t.test (Bonferroni=0.007?; two-sided?)
n0 <- length(group0)
n1 <- length (group1)
power_result <- pwr.t.test(d = cohen_d, n = min(n0, n1), sig.level = 0.05, type = "two.sample", alternative = "greater")
power <- power_result$power
# Store the results
df[col, "t_statistic"] <- round(results$statistic, 2)
df[col, "p_value"] <- round(results$p.value, 2)
df[col, "group_mean_Patients"] <- round(mean(group0), 2)
df[col, "sd_Patients"] <- round(sd(group0), 2)
df[col, "group_mean_HC"] <- round(mean(group1), 2)
df[col, "sd_HC"] <- round(sd(group1), 2)
df[col, "cohen_d"] <- round(cohen_d, 2)
df[col, "power"] <- round(power, 2)
}
return(df)
}
t_test_table <- t_test_mult_cols(df_basis = Patients_vs_HC_imp, cols = BIS_columns_renamed)
pander(t_test_table, style = "rmarkdown", fontsize = "tiny")
t_test_mult_cols <- function(df_basis, cols) {
df <- data.frame(t_statistic = numeric(length(cols)), p_value = numeric(length(cols)),
group_mean_Patients = numeric(length(cols)), sd_Patients = numeric(length(cols)),
group_mean_HC = numeric(length(cols)), sd_HC = numeric(length(cols)),
cohen_d = numeric(length(cols)))
rownames(df) <- cols
for (col in cols) {
# Using the non-formula interface
group0 <- df_basis[df_basis[["Gruppe"]] == 0, col]
group1 <- df_basis[df_basis[["Gruppe"]] == 1, col]
results <- t.test(group0, group1, paired = FALSE, var.equal = FALSE)
#Alternativ using formula method:
#results <- t.test(df_basis[[col]] ~ df_basis[["Gruppe"]], paired = FALSE, var.equal = FALSE)
# Calculate Cohen's d using the cohen.d function (effect size)
cohen_d_result <- cohen.d(group0, group1, hedges.correction = FALSE)
cohen_d <- cohen_d_result$estimate
# Calculate power using pwr.t.test (Bonferroni=0.007?; two-sided?)
n0 <- length(group0)
n1 <- length (group1)
power_result <- pwr.t.test(d = cohen_d, n = min(n0, n1), sig.level = 0.05, type = "two.sample", alternative = "greater")
power <- power_result$power
# Store the results
df[col, "t_statistic"] <- round(results$statistic, 2)
df[col, "p_value"] <- round(results$p.value, 2)
df[col, "group_mean_Patients"] <- round(mean(group1), 2)
df[col, "sd_Patients"] <- round(sd(group0), 2)
df[col, "group_mean_HC"] <- round(mean(group0), 2)
df[col, "sd_HC"] <- round(sd(group1), 2)
df[col, "cohen_d"] <- round(cohen_d, 2)
df[col, "power"] <- round(power, 2)
}
return(df)
}
t_test_table <- t_test_mult_cols(df_basis = Patients_vs_HC_imp, cols = BIS_columns_renamed)
pander(t_test_table, style = "rmarkdown", fontsize = "tiny")
## Merge patients pre
Patients_pre_2 <- merge(NumberLetter_Patients_Pre, Stroop_Patients_Pre, by = "Subject")
Patients_pre_3 <- merge(Patients_pre_2, TwoBack_Patients_Pre, by = "Subject")
Patients_pre_3$time <- "pre"
## Merge patients Post
Patients_post_2 <- merge(NumberLetter_Patients_Post, Stroop_Patients_Post, by = "Subject")
Patients_post_3 <- merge(Patients_post_2, TwoBack_Patients_Post, by = "Subject")
Patients_post_3$time <- "post"
# Combine data
Patients_pre_3$Subject <- Patients_pre_3$Subject + 600 # This was the ID given
Patients_pre_vs_post <- rbind(Patients_post_3, Patients_pre_3)
# Remove data if subjects had only pre-values
subject_counts <- table(Patients_pre_vs_post$Subject)
multiple_rows_subjects <- names(subject_counts)[subject_counts > 1]
Patients_pre_vs_post_clean <- Patients_pre_vs_post[Patients_pre_vs_post$Subject %in% multiple_rows_subjects, ]
# Reduce to BIS
BIS_columns <- colnames(Patients_pre_vs_post_clean)[startsWith(colnames(Patients_pre_vs_post_clean), "BIS")]
Patients_pre_vs_post_imp <- Patients_pre_vs_post_clean[,c("Subject",BIS_columns,"time")]
## Add better names
Patients_pre_vs_post_imp <- Patients_pre_vs_post_imp %>%
rename(NumberLetter_BIS_Repeat = BIS_Repeat,
NumberLetter_BIS_Switch = BIS_Switch,
Stroop_BIS_Congruent = BIS_Congruent,
Stroop_BIS_Incongruent = BIS_Incongruent,
TwoBack_BIS_Total = BIS_Total,
TwoBack_BIS_Target = BIS_Target,
TwoBack_BIS_Foil = BIS_Foil)
BIS_columns_renamed <- grep("BIS", colnames(Patients_pre_vs_post_imp), value = TRUE)
#Helper function to avoid redundancy (Get pre and post data in one place for assumption and Welch test)
get_pre_post_data <- function(df_basis, col) {
pre_data <- df_basis[df_basis[["time"]] == "pre", col]
post_data <- df_basis[df_basis[["time"]] == "post", col]
return(list(pre = pre_data, post = post_data))
}
paired_t_test_mult_cols <- function(df_basis, cols) {
df <- data.frame(t_statistic = numeric(length(cols)), p_value = numeric(length(cols)),
group_mean_pre = numeric(length(cols)), group_mean_post = numeric(length(cols)),
cohen_d = numeric(length(cols)))
rownames(df) <- cols
for (col in cols) {
# Get pre and post data using get_pre_post_data helper function
data <- get_pre_post_data(df_basis, col)
pre_data <- data$pre
post_data <- data$post
# non-formula interface as before
results <- t.test(pre_data, post_data, paired = TRUE, var.equal = FALSE)
#Alternativ using formula method:
#results <- t.test(df_basis[[col]] ~ df_basis[["time"]], paired = TRUE, var.equal = FALSE)
# Calculate Cohen's d using the cohen.d function for paired samples (effect size)
cohen_d_result <- cohen.d(post_data, pre_data, paired = TRUE)
cohen_d <- cohen_d_result$estimate
# Calculate power using pwr.t.test
n <- length(pre_data)
power_result <- pwr.t.test(d = cohen_d, n = n, sig.level = 0.05, type = "paired", alternative = "greater")
#0.007? (Bonferroni)
power <- power_result$power
# Store the results
df[col, "t_statistic"] <- round(results$statistic, 2)
df[col, "p_value"] <- round(results$p.value, 2)
df[col, "group_mean_pre"] <- round(mean(pre_data), 2)
df[col, "sd_pre"] <- round(sd(pre_data), 2)
df[col, "group_mean_post"] <- round(mean(post_data), 2)
df[col, "sd_post"] <- round(sd(post_data), 2)
df[col, "cohen_d"] <- round(cohen_d, 2)
df[col, "power"] <- round(power, 2)
}
return(df)
}
t_test_table_pre_post <- paired_t_test_mult_cols(df_basis = Patients_pre_vs_post_imp, cols = BIS_columns_renamed)
pander(t_test_table_pre_post)
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(dplyr)
library(tidyr)
library(pander)
library(effsize)
library(pwr)
library(gtsummary)
NumberLetter_HC <- read.csv("Z:/Projekte_Meinke/Old_projects/Labrotation_Rebecca/Daten_Gruppenvergleich/Without_wrong_responses/NumberLetter_HC.csv")
NumberLetter_Patients_Post <- read.csv("Z:/Projekte_Meinke/Old_projects/Labrotation_Rebecca/Daten_Gruppenvergleich/Without_wrong_responses/NumberLetter_Patients_Post.csv")
NumberLetter_Patients_Pre <-  read.csv("Z:/Projekte_Meinke/Old_projects/Labrotation_Rebecca/Daten_Gruppenvergleich/Without_wrong_responses/NumberLetter_Patients_Pre.csv")
Stroop_HC <- read.csv("Z:/Projekte_Meinke/Old_projects/Labrotation_Rebecca/Daten_Gruppenvergleich/Without_wrong_responses/Stroop_HC.csv")
Stroop_Patients_Post <-  read.csv("Z:/Projekte_Meinke/Old_projects/Labrotation_Rebecca/Daten_Gruppenvergleich/Without_wrong_responses/Stroop_Patients_Post.csv")
Stroop_Patients_Pre <-  read.csv("Z:/Projekte_Meinke/Old_projects/Labrotation_Rebecca/Daten_Gruppenvergleich/Without_wrong_responses/Stroop_Patients_Pre.csv")
TwoBack_HC <- read.csv("Z:/Projekte_Meinke/Old_projects/Labrotation_Rebecca/Daten_Gruppenvergleich/Without_wrong_responses/TwoBack_HC.csv")
TwoBack_Patients_Post <-  read.csv("Z:/Projekte_Meinke/Old_projects/Labrotation_Rebecca/Daten_Gruppenvergleich/Without_wrong_responses/TwoBack_Patients_Post.csv")
TwoBack_Patients_Pre <-  read.csv("Z:/Projekte_Meinke/Old_projects/Labrotation_Rebecca/Daten_Gruppenvergleich/Without_wrong_responses/TwoBack_Patients_Pre.csv")
data_all <- haven::read_dta('Z:/Projekte_Meinke/Old_projects/Labrotation_Rebecca/CognitiveControl_Treatment/Data_Kevin_28.07.23.dta')
colnames(data_all)[which(colnames(data_all) == "id")] <- "Subject"
# Merge patients and controls
## 1. Merge patients Pre (different tasks)
Patients_pre_2 <- merge(NumberLetter_Patients_Pre, Stroop_Patients_Pre, by = "Subject")
Patients_pre_3 <- merge(Patients_pre_2, TwoBack_Patients_Pre, by = "Subject")
## 2. Merge controls (different tasks)
Controls_2 <- merge(NumberLetter_HC, Stroop_HC, by = "Subject")
Controls_3 <- merge(Controls_2, TwoBack_HC, by = "Subject")
## 3. Merge Controls and patients
Patients_vs_HC <- rbind(Patients_pre_3, Controls_3)
## 4. Reduce dataset to BIS columns
BIS_columns <- colnames(Patients_vs_HC)[startsWith(colnames(Patients_vs_HC), "BIS")]
Patients_vs_HC_imp <- Patients_vs_HC[,c("Subject",BIS_columns,"Gruppe")]
## 5. Add better names
Patients_vs_HC_imp <- Patients_vs_HC_imp %>%
rename(NumberLetter_BIS_Repeat = BIS_Repeat,
NumberLetter_BIS_Switch = BIS_Switch,
Stroop_BIS_Congruent = BIS_Congruent,
Stroop_BIS_Incongruent = BIS_Incongruent,
TwoBack_BIS_Total = BIS_Total,
TwoBack_BIS_Target = BIS_Target,
TwoBack_BIS_Foil = BIS_Foil)
BIS_columns_renamed <- grep("BIS", colnames(Patients_vs_HC_imp), value = TRUE)
## 6. Add confounds (Alter, Geschlecht, Abschluss)
Patients_vs_HC_imp_conf <- merge(data_all[,c("Subject","Alter","Geschlecht","Abschluss")], Patients_vs_HC_imp, by = "Subject")
t_test_mult_cols <- function(df_basis, cols) {
df <- data.frame(t_statistic = numeric(length(cols)), p_value = numeric(length(cols)),
group_mean_Patients = numeric(length(cols)), sd_Patients = numeric(length(cols)),
group_mean_HC = numeric(length(cols)), sd_HC = numeric(length(cols)),
cohen_d = numeric(length(cols)))
rownames(df) <- cols
for (col in cols) {
# Using the non-formula interface
group0 <- df_basis[df_basis[["Gruppe"]] == 0, col]
group1 <- df_basis[df_basis[["Gruppe"]] == 1, col]
results <- t.test(group0, group1, paired = FALSE, var.equal = FALSE)
#Alternativ using formula method:
#results <- t.test(df_basis[[col]] ~ df_basis[["Gruppe"]], paired = FALSE, var.equal = FALSE)
# Calculate Cohen's d using the cohen.d function (effect size)
cohen_d_result <- cohen.d(group0, group1, hedges.correction = FALSE)
cohen_d <- cohen_d_result$estimate
# Calculate power using pwr.t.test (Bonferroni=0.007?; two-sided?)
n0 <- length(group0)
n1 <- length (group1)
power_result <- pwr.t.test(d = cohen_d, n = min(n0, n1), sig.level = 0.05, type = "two.sample", alternative = "greater")
power <- power_result$power
# Store the results
df[col, "t_statistic"] <- round(results$statistic, 2)
df[col, "p_value"] <- round(results$p.value, 2)
df[col, "group_mean_Patients"] <- round(mean(group1), 2)
df[col, "sd_Patients"] <- round(sd(group0), 2)
df[col, "group_mean_HC"] <- round(mean(group0), 2)
df[col, "sd_HC"] <- round(sd(group1), 2)
df[col, "cohen_d"] <- round(cohen_d, 2)
df[col, "power"] <- round(power, 2)
}
return(df)
}
t_test_table <- t_test_mult_cols(df_basis = Patients_vs_HC_imp, cols = BIS_columns_renamed)
pander(t_test_table, style = "rmarkdown", fontsize = "tiny")
## Merge patients pre
Patients_pre_2 <- merge(NumberLetter_Patients_Pre, Stroop_Patients_Pre, by = "Subject")
Patients_pre_3 <- merge(Patients_pre_2, TwoBack_Patients_Pre, by = "Subject")
Patients_pre_3$time <- "pre"
## Merge patients Post
Patients_post_2 <- merge(NumberLetter_Patients_Post, Stroop_Patients_Post, by = "Subject")
Patients_post_3 <- merge(Patients_post_2, TwoBack_Patients_Post, by = "Subject")
Patients_post_3$time <- "post"
# Combine data
Patients_pre_3$Subject <- Patients_pre_3$Subject + 600 # This was the ID given
Patients_pre_vs_post <- rbind(Patients_post_3, Patients_pre_3)
# Remove data if subjects had only pre-values
subject_counts <- table(Patients_pre_vs_post$Subject)
multiple_rows_subjects <- names(subject_counts)[subject_counts > 1]
Patients_pre_vs_post_clean <- Patients_pre_vs_post[Patients_pre_vs_post$Subject %in% multiple_rows_subjects, ]
# Reduce to BIS
BIS_columns <- colnames(Patients_pre_vs_post_clean)[startsWith(colnames(Patients_pre_vs_post_clean), "BIS")]
Patients_pre_vs_post_imp <- Patients_pre_vs_post_clean[,c("Subject",BIS_columns,"time")]
## Add better names
Patients_pre_vs_post_imp <- Patients_pre_vs_post_imp %>%
rename(NumberLetter_BIS_Repeat = BIS_Repeat,
NumberLetter_BIS_Switch = BIS_Switch,
Stroop_BIS_Congruent = BIS_Congruent,
Stroop_BIS_Incongruent = BIS_Incongruent,
TwoBack_BIS_Total = BIS_Total,
TwoBack_BIS_Target = BIS_Target,
TwoBack_BIS_Foil = BIS_Foil)
BIS_columns_renamed <- grep("BIS", colnames(Patients_pre_vs_post_imp), value = TRUE)
paired_t_test_mult_cols <- function(df_basis, cols) {
df <- data.frame(t_statistic = numeric(length(cols)), p_value = numeric(length(cols)),
group_mean_pre = numeric(length(cols)), group_mean_post = numeric(length(cols)),
cohen_d = numeric(length(cols)))
rownames(df) <- cols
for (col in cols) {
# Get pre and post data using get_pre_post_data helper function
data <- get_pre_post_data(df_basis, col)
pre_data <- data$pre
post_data <- data$post
# non-formula interface as before
results <- t.test(pre_data, post_data, paired = TRUE, var.equal = FALSE)
#Alternativ using formula method:
#results <- t.test(df_basis[[col]] ~ df_basis[["time"]], paired = TRUE, var.equal = FALSE)
# Calculate Cohen's d using the cohen.d function for paired samples (effect size)
cohen_d_result <- cohen.d(post_data, pre_data, paired = TRUE)
cohen_d <- cohen_d_result$estimate
# Calculate power using pwr.t.test
n <- length(pre_data)
power_result <- pwr.t.test(d = cohen_d, n = n, sig.level = 0.05, type = "paired", alternative = "greater")
#0.007? (Bonferroni)
power <- power_result$power
# Store the results
df[col, "t_statistic"] <- round(results$statistic, 2)
df[col, "p_value"] <- round(results$p.value, 2)
df[col, "group_mean_pre"] <- round(mean(pre_data), 2)
df[col, "sd_pre"] <- round(sd(pre_data), 2)
df[col, "group_mean_post"] <- round(mean(post_data), 2)
df[col, "sd_post"] <- round(sd(post_data), 2)
df[col, "cohen_d"] <- round(cohen_d, 2)
df[col, "power"] <- round(power, 2)
}
return(df)
}
t_test_table_pre_post <- paired_t_test_mult_cols(df_basis = Patients_pre_vs_post_imp, cols = BIS_columns_renamed)
#Helper function to avoid redundancy (Get pre and post data in one place for assumption and Welch test)
get_pre_post_data <- function(df_basis, col) {
pre_data <- df_basis[df_basis[["time"]] == "pre", col]
post_data <- df_basis[df_basis[["time"]] == "post", col]
return(list(pre = pre_data, post = post_data))
}
paired_t_test_mult_cols <- function(df_basis, cols) {
df <- data.frame(t_statistic = numeric(length(cols)), p_value = numeric(length(cols)),
group_mean_pre = numeric(length(cols)), group_mean_post = numeric(length(cols)),
cohen_d = numeric(length(cols)))
rownames(df) <- cols
for (col in cols) {
# Get pre and post data using get_pre_post_data helper function
data <- get_pre_post_data(df_basis, col)
pre_data <- data$pre
post_data <- data$post
# non-formula interface as before
results <- t.test(pre_data, post_data, paired = TRUE, var.equal = FALSE)
#Alternativ using formula method:
#results <- t.test(df_basis[[col]] ~ df_basis[["time"]], paired = TRUE, var.equal = FALSE)
# Calculate Cohen's d using the cohen.d function for paired samples (effect size)
cohen_d_result <- cohen.d(post_data, pre_data, paired = TRUE)
cohen_d <- cohen_d_result$estimate
# Calculate power using pwr.t.test
n <- length(pre_data)
power_result <- pwr.t.test(d = cohen_d, n = n, sig.level = 0.05, type = "paired", alternative = "greater")
#0.007? (Bonferroni)
power <- power_result$power
# Store the results
df[col, "t_statistic"] <- round(results$statistic, 2)
df[col, "p_value"] <- round(results$p.value, 2)
df[col, "group_mean_pre"] <- round(mean(pre_data), 2)
df[col, "sd_pre"] <- round(sd(pre_data), 2)
df[col, "group_mean_post"] <- round(mean(post_data), 2)
df[col, "sd_post"] <- round(sd(post_data), 2)
df[col, "cohen_d"] <- round(cohen_d, 2)
df[col, "power"] <- round(power, 2)
}
return(df)
}
t_test_table_pre_post <- paired_t_test_mult_cols(df_basis = Patients_pre_vs_post_imp, cols = BIS_columns_renamed)
pander(t_test_table_pre_post)
