---
title: "Group Comparison: Responders vs. Nonresponders"
authors: "Charlotte Meinke, Rebecca Delfendahl, Till Julius Adam"
date: "2024-09-04"
output:
  html_document:
    toc: true
    toc_float: true
    code_folding: hide
---
<style type="text/css">
.main-container { /* Adjust main blocks */
  max-width: 100% !important;
  margin: auto;
}

body {
  font-family: "Georgia", serif !important; /* Set the font for the entire document */
}

.tocify { /* Adjust table of contents */
  max-width: 100% !important;
}
</style>

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(dplyr)
library(tidyr)
library(pander)
library(effsize)
library(pwr)
library(gtsummary)
library(gt)
library(car)
```

# Import Data 

```{r}
basic_path = "Y:/PsyThera/Projekte_Meinke/Old_projects/Labrotation_Rebecca/0_Datapreparation/Daten_Gruppenvergleich/With_wrong_responses/outliers-removed"
param_suffix = basename(basic_path)
data_Pat_pre <- read.csv(file.path(basic_path,"Data_Patients_Pre.csv"))
```

# Prepare dataset
Remove all patients that had no post-treatment score
```{r}
data_Pat_pre_clean <- data_Pat_pre[!is.na(data_Pat_pre$Response),]
```

# Characteristics Table: Descriptive Statistics
```{r}
# Data frame that codes variables according to study protocol
characteristics_data <- Patients_vs_HC %>%
  select(Response, Alter, Geschlecht, Abschluss, 
         T1_BAT_BDI_II_score, T1_BAT_BIS_11_score, T1_BAT_CFC_14_score, 
         T1_BAT_FAS_score, T1_BAT_Kirby_k_score, T1_BAT_SRHI_score, T1_BAT_STAI_T_score) %>%
  mutate(Response = factor(Response, levels = c(1, 0), labels = c("Response", "Non-Response")),
         Geschlecht = factor(Geschlecht, levels = c(0, 1), labels = c("Male", "Female")),
         Abschluss = factor(Abschluss, levels = c(1, 2, 3, 4), 
                            labels = c("Basic secondary education", "Intermediate secondary education",
                                       "Higher secondary education", "Other")))

# Create a summary table with a subheading for "Baseline Assessment"
characteristics_table <- characteristics_data %>%
  tbl_summary(
    by = Response,  # Compare by Response (Response vs. Non-Response)
    label = list(
      Alter ~ "Age",
      Geschlecht ~ "Sex",
      Abschluss ~ "Education",
      T1_BAT_BDI_II_score ~ "BDI-II Score",
      T1_BAT_BIS_11_score ~ "BIS-11 Score",
      T1_BAT_CFC_14_score ~ "CFC-14 Score",
      T1_BAT_FAS_score ~ "FAS Score",
      T1_BAT_Kirby_k_score ~ "Kirby k Score",
      T1_BAT_SRHI_score ~ "SRHI Score",
      T1_BAT_STAI_T_score ~ "STAI-T Score"
    ),
    statistic = list(
      all_continuous() ~ "{mean} ({sd})",
      all_categorical() ~ "{n}",
      Geschlecht ~ "{n} ({p}%)"  # Show counts and percentages for Geschlecht
    ),
    missing = "no"
  ) %>%
  modify_header(label ~ "**Characteristic**") %>%
  modify_spanning_header(
    starts_with("T1_BAT_") ~ "**Baseline Assessment**"
  ) %>%
  # Remove the row for "Male" in the "Geschlecht" variable
  modify_table_body(
    ~ .x %>% filter(!(variable == "Geschlecht" & label == "Male"))
  )

characteristics_table
```

# Inferential statistics 
## Test for variance homogeneity
### Define function
```{r}
# Perform Levene's test for homogeneity of variance on task performance measures
levene_test_mult_cols <- function(df_basis, cols) {
  df <- data.frame(p_value = numeric(length(cols)))
  rownames(df) <- cols
  
  for (i in seq_along(cols)) {
    col <- cols[i]
    # Remove NA-cases per variable/task
    df_basis_nomissings <- df_basis[!is.na(df_basis[[col]]),]
    df_basis_nomissings[[col]] <- as.numeric(df_basis_nomissings[[col]])
    # Perform Levene's test, treating 'Response' as a factor
    levene_result <- car::leveneTest(df_basis_nomissings[[col]] ~ df_basis_nomissings[["Response"]])
    df[col, "p_value"] <- round(levene_result[1, "Pr(>F)"], 4)
  }
  
  return(df)
}
```

### Perform levene test
```{r}
# Ensure "Response" is treated as a factor
data_Pat_pre_clean$Response <- as.factor(data_Pat_pre_clean$Response)

# Define the columns for which to perform the test (e.g., task performance measures)
imp_columns <- c("NumberLetter_BIS_Repeat", "NumberLetter_BIS_Switch", 
                 "NumberLetter_BIS_Diff_Score", "Stroop_BIS_Congruent", 
                 "Stroop_BIS_Incongruent", "Stroop_BIS_Diff_Score", 
                 "TwoBack_BIS_Foil", "TwoBack_BIS_Target", "TwoBack_BIS_Total", 
                 "SSRT")

# Perform Levene's test
levene_test_table <- levene_test_mult_cols(df_basis = data_Pat_pre_clean, cols = imp_columns)
pander(levene_test_table, style = "rmarkdown", fontsize = "tiny")
```
Levene test shows complete variance homoegeneity for all task conditions between responders and non-responders.


## Calculate t-tests 
### Define function
```{r}
# Perform t-tests for each task and store results
t_test_mult_cols <- function(df_basis, cols) {
  # Initialize empty dataframe
  df <- data.frame(t_statistic = numeric(length(cols)), p_value = numeric(length(cols)),
                   group_mean_Response = numeric(length(cols)), sd_Response = numeric(length(cols)),
                   group_mean_NonResponse = numeric(length(cols)), sd_NonResponse = numeric(length(cols)),
                   cohen_d = numeric(length(cols)))
  rownames(df) <- cols
  
  for (i in seq_along(cols)) {
    col <- cols[i]
    
    # Separate groups by Response = 1 and Response = 0
    group1 <- na.omit(df_basis[df_basis[["Response"]] == 1, col])
    group0 <- na.omit(df_basis[df_basis[["Response"]] == 0, col])
    #Alternativ using formula method:
      #results <- t.test(df_basis[[col]] ~ df_basis[["Response"]], paired = FALSE, var.equal = TRUE)
    
    # Perform standard t-test (since variance homogeneity holds)
    results <- t.test(group1, group0, paired = FALSE, var.equal = TRUE)
    
    # Calculate Cohen's d
    cohen_d_result <- cohen.d(group1, group0, hedges.correction = FALSE)
    cohen_d <- cohen_d_result$estimate
    
    # Calculate power
    n0 <- length(group0)
    n1 <- length(group1)
    power_result <- pwr.t.test(d = cohen_d, n = min(n0, n1), sig.level = 0.05, type = "two.sample", alternative = "greater")
    power <- power_result$power
    
    # Store the results
    df[col, "t_statistic"] <- round(results$statistic, 2)
    df[col, "p_value"] <- round(results$p.value, 4)
    df[col, "group_mean_Response"] <- round(mean(group1), 2)
    df[col, "sd_Response"] <- round(sd(group1), 2)
    df[col, "group_mean_NonResponse"] <- round(mean(group0), 2)
    df[col, "sd_NonResponse"] <- round(sd(group0), 2)
    df[col, "cohen_d"] <- round(cohen_d, 2)
    df[col, "power"] <- round(power, 2)
  }
  
  return(df)
}
```

### Perform t-test
```{r}
t_test_table <- t_test_mult_cols(df_basis = data_Pat_pre_clean, cols = imp_columns)
pander(t_test_table, style = "rmarkdown", split.table = Inf, fontsize = "tiny")
```
No significant was found for any of the tasks.
Potential reason: low power. Even the largest power for TwoBack_BIS_Foil of 0.22 with a cohen's d of 0.2 would require a sample size of 144 to find a significant effect, as a priori power power analysis shows. However, the patient group is only about half as large as that (n=89), not to speak of the tasks with even smaller power (e.g., NumberLetter_BIS_Repeat with 0.01)


###  Table: Inferential Statistics
```{r}
# data frame with inferential statistics (p-value, Cohen's d, power) for Response vs. Non-response
inferential_stats_response_df <- data.frame(
  Task = c("Number Letter Repeat", "Number Letter Switch", "Number Letter Difference BIS Score",
           "Stroop Congruent", "Stroop Incongruent", "Stroop BIS Difference Score",
           "Two Back Foil", "Two Back Target", "Two Back Difference BIS Score", "SSRT"),
  p_value = t_test_table$p_value,
  cohen_d = t_test_table$cohen_d,
  power = t_test_table$power
)

# inferential statistics table for Response vs. Non-response
inferential_stats_response_table <- inferential_stats_response_df %>%
  gt() %>%
  tab_header(
    title = "Inferential Statistics: Response vs. Non-response"
  ) %>%
  cols_label(
    Task = html("<b>Task</b>"),
    p_value = html("<b>p-value</b>"),
    cohen_d = html("<b>Cohen's d</b>"),
    power = html("<b>Power</b>")
  ) %>%
  fmt_number(
    columns = c(p_value, cohen_d, power),
    decimals = 2
  )

inferential_stats_response_table
```

# Visualization of group differences
## Prepare data
```{r}
# Reshape data from wide to long format, including SSRT, for Response vs. Nonresponse
Response_vs_NonResponse_long <- data_Pat_pre %>%
  pivot_longer(cols = all_of(imp_columns), # imp_columns now includes SSRT
               names_to = "Condition",
               values_to = "BIS_Score") %>%
  drop_na()

# Add a new task variable for faceting
Response_vs_NonResponse_long <- Response_vs_NonResponse_long %>%
  mutate(Task = case_when(
    grepl("NumberLetter", Condition) ~ "Number-Letter Task",
    grepl("Stroop", Condition) ~ "Stroop Task",
    grepl("TwoBack", Condition) ~ "2-Back Task",
    Condition == "SSRT" ~ "Stop Signal Task"
  ))

# Remove prefixes from Condition labels, keeping Task intact
Response_vs_NonResponse_long <- Response_vs_NonResponse_long %>%
  mutate(Condition = gsub("NumberLetter_BIS_|Stroop_BIS_|TwoBack_BIS_", "", Condition)) %>%
  mutate(Condition = as.character(Condition)) %>%
  
  # Set the condition order for each task separately to avoid conflicts (cannot both be "Diff_Score")
  mutate(Condition = ifelse(Task == "NumberLetter" & Condition == "Diff_Score", "Diff_Score NL", Condition)) %>%
  mutate(Condition = ifelse(Task == "Stroop" & Condition == "Diff_Score", "Diff_Score Stroop", Condition)) %>%
  
  # Convert Condition to factor with ordering
  mutate(Condition = case_when(
    Task == "NumberLetter" ~ factor(Condition, levels = c("Repeat", "Switch", "Diff_Score NL")),
    Task == "Stroop" ~ factor(Condition, levels = c("Congruent", "Incongruent", "Diff_Score Stroop")),
    Task == "TwoBack" ~ factor(Condition, levels = c("Target", "Foil", "Total")),
    TRUE ~ as.factor(Condition)
  ))

# Convert "Response" to factor
Response_vs_NonResponse_long$Response <- factor(Response_vs_NonResponse_long$Response, levels = c(0, 1), labels = c("Nonresponders", "Responders"))
```

## Plotting
```{r}
# Create violin plots with mean and rename conditions in the plot

violin_plots_response_vs_nonresponse <- ggplot(Response_vs_NonResponse_long, aes(x = Condition, y = BIS_Score, fill = Response)) +
  geom_violin(position = position_dodge(width = 0.8)) +
  stat_summary(fun.data = mean_sdl, geom = "pointrange", # mult = 2 (SD) by default
               position = position_dodge(width = 0.8)) + # width = 0.65, fatten = 2
  facet_wrap(~ Task, scales = "free") +
  labs(x = "",
       y = "Performance Score",
       fill = "Group") +
  scale_x_discrete(labels = function(x) {
    x[x == "Diff_Score"] <- "Difference \nScore"
    x[x == "Diff_Score Stroop"] <- "Difference \nScore"
    x[x == "Total"] <- "Difference \nScore"
    return(x)
  }) +
  scale_fill_manual(values = c("Nonresponders" = "#D3D3D3", #colors 
                               "Responders" = "#48CFCB")) +
  theme_bw() +
  theme(
    text = element_text(family = "Arial"), #Font
    axis.title = element_text(size = 24),
    axis.title.y = element_text(size = 24, margin = margin(r = 30)),
    axis.text = element_text(size = 18),
    legend.title = element_text(size = 24),
    legend.text = element_text(size = 18),
    strip.text = element_text(size = 20),
    panel.spacing.x = unit(3, "lines")
  )
print(violin_plots_response_vs_nonresponse)

ggsave(paste0("response_vs_nonresponse",param_suffix,".svg"),violin_plots_response_vs_nonresponse,
       width = 10)
```
