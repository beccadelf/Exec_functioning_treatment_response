---
title: "Group Comparison: Healthy Controls vs. Patients"
authors: "Charlotte Meinke, Rebecca Delfendahl, Till Julius Adam"
date: "2024-09-04"
output:
  html_document:
    toc: true
    toc_float: true
    code_folding: hide
    df_print: paged
params:
  input_data_path: "Z:/Projekte_Meinke/Old_projects/Labrotation_Rebecca/0_Datapreparation/Daten_Gruppenvergleich/new/RT_trimmed_RT_wrong_removed/BIS/outliers-removed"
---
<style type="text/css">
.main-container { /* Adjust main blocks */
  max-width: 100% !important;
  margin: auto;
}

body {
  font-family: "Georgia", serif !important; /* Set the font for the entire document */
}

.tocify { /* Adjust table of contents */
  max-width: 100% !important;
}
</style>

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(dplyr)
library(tidyr)
library(pander)
library(effsize)
library(pwr)
library(gtsummary)
library(gt)
library(car)
library(flextable)
library(officer)
```

# Importing Data
```{r}
basic_path = params$input_data_path
data_HC <- read.csv(file.path(basic_path,"Data_HC.csv"))
data_Pat_pre <- read.csv(file.path(basic_path,"Data_Patients_Pre.csv"))
```

# Prepare dataset
```{r}
## 1. Merge patients pre and controls
Patients_vs_HC <- rbind(data_Pat_pre, data_HC)

## 2. Reduce dataset to executive functions of interest (BIS columns and SSRT)
BIS_columns <- colnames(Patients_vs_HC)[grep("BIS", colnames(Patients_vs_HC))]
BIS_columns <- BIS_columns[BIS_columns != "T1_BAT_BIS_11_score"] # BIS-11 is a questionnaire
imp_columns <- c(BIS_columns,"SSRT")
Patients_vs_HC_imp <- Patients_vs_HC[,c("Subject","Gruppe",imp_columns)]

## 3. Add confounds (Alter, Geschlecht, Abschluss)
Patients_vs_HC_imp_conf <- merge(Patients_vs_HC[,c("Subject","Alter","Geschlecht","Abschluss")], Patients_vs_HC_imp, by = "Subject")
```
In total, data for `r nrow(Patients_vs_HC_imp[Patients_vs_HC_imp$Gruppe == 1,])` patients and `r nrow(Patients_vs_HC_imp[Patients_vs_HC_imp$Gruppe == 0,])` healthy controls were available. When outliers were removed, the number of subjects varied slightly: 
Number-Letter Task: `r nrow(Patients_vs_HC_imp[Patients_vs_HC_imp$Gruppe == 0 & !is.na(Patients_vs_HC_imp$NumberLetter_BIS_Repeat),])` healthy controls,  `r nrow(Patients_vs_HC_imp[Patients_vs_HC_imp$Gruppe == 1 & !is.na(Patients_vs_HC_imp$NumberLetter_BIS_Repeat),])`
Stroop Task: `r nrow(Patients_vs_HC_imp[Patients_vs_HC_imp$Gruppe == 0 & !is.na(Patients_vs_HC_imp$Stroop_BIS_Congruent),])` healthy controls,  `r nrow(Patients_vs_HC_imp[Patients_vs_HC_imp$Gruppe == 1 & !is.na(Patients_vs_HC_imp$Stroop_BIS_Congruent),])`
2back-Task: `r nrow(Patients_vs_HC_imp[Patients_vs_HC_imp$Gruppe == 0 & !is.na(Patients_vs_HC_imp$TwoBack_BIS_Total),])` healthy controls,  `r nrow(Patients_vs_HC_imp[Patients_vs_HC_imp$Gruppe == 1 & !is.na(Patients_vs_HC_imp$TwoBack_BIS_Total),])`
SSRT: `r nrow(Patients_vs_HC_imp[Patients_vs_HC_imp$Gruppe == 0 & !is.na(Patients_vs_HC_imp$SSRT),])` healthy controls,  `r nrow(Patients_vs_HC_imp[Patients_vs_HC_imp$Gruppe == 1 & !is.na(Patients_vs_HC_imp$SSRT),])`
Find assumption test for normality in script "Testing Normality".

# Inferential statistics
## Check variance homogeneity
```{r}
# Ensure "Gruppe" is treated as a factor
Patients_vs_HC_imp$Gruppe <- as.factor(Patients_vs_HC_imp$Gruppe)

# Function to perform Levene's test on multiple columns
levene_test_mult_cols <- function(df_basis, cols) {
  df <- data.frame(p_value = numeric(length(cols)))
  rownames(df) <- cols
  
  for (i in seq_along(cols)) {
    col <- cols[i]
    # Perform Levene's test, treating 'Gruppe' as a factor
    levene_result <- car::leveneTest(df_basis[[col]] ~ df_basis[["Gruppe"]])
    df[col, "p_value"] <- round(levene_result[1, "Pr(>F)"], 4)
  }
  
  return(df)
}

# Perform Levene's test for homogeneity of variance
levene_test_table <- levene_test_mult_cols(df_basis = Patients_vs_HC_imp, cols = imp_columns)
pander(levene_test_table, style = "rmarkdown", fontsize = "tiny")
levene_test_table
```

## Calculate Welch t-test
```{r}
t_test_mult_cols <- function(df_basis, cols) {
  # Calculate a t-test for multiple comparisons and store the results in a dataframe
  df <- data.frame(group_mean_Patients = numeric(length(cols)), sd_Patients = numeric(length(cols)),
                   group_mean_HC = numeric(length(cols)), sd_HC = numeric(length(cols)),df = numeric(length(cols)), t_statistic = numeric(length(cols)), p_value = numeric(length(cols)),
                   cohen_d = numeric(length(cols)))
  rownames(df) <- cols
  p_values_raw <- numeric(length(cols))  # Vector to store raw p-values
  
  for (i in seq_along(cols)) {
    col <- cols[i] #seq_along for sequencing column indices
    
    # Using the non-formula interface
    group0 <- na.omit(df_basis[df_basis[["Gruppe"]] == 0, col])
    group1 <- na.omit(df_basis[df_basis[["Gruppe"]] == 1, col])
    results <- t.test(group0, group1, paired = FALSE, var.equal = FALSE)
    #Alternativ using formula method:
      #results <- t.test(df_basis[[col]] ~ df_basis[["Gruppe"]], paired = FALSE, var.equal = FALSE)
    
    # Store raw p-values for BH correction
    p_values_raw[i] <- results$p.value
    
    # Calculate Cohen's d using the cohen.d function (effect size)
    cohen_d_result <- cohen.d(group0, group1, hedges.correction = FALSE)
    cohen_d <- cohen_d_result$estimate
    
    # Calculate power using pwr.t.test
    n0 <- length(group0)
    n1 <- length(group1)
    power_result <- pwr.t.test(d = cohen_d, n = min(n0, n1), sig.level = 0.05, type = "two.sample", alternative = "greater")
    power <- power_result$power
    
    # Store the results
    df[col, "t_statistic"] <- round(results$statistic, 2)
    df[col, "df"] <- round(results[["parameter"]][["df"]], 2)
    df[col, "p_value"] <- round(results$p.value, 2)
    df[col, "group_mean_Patients"] <- round(mean(group1), 2)
    df[col, "sd_Patients"] <- round(sd(group1), 2)
    df[col, "group_mean_HC"] <- round(mean(group0), 2)
    df[col, "sd_HC"] <- round(sd(group0), 2)
    df[col, "cohen_d"] <- round(cohen_d, 2)
    df[col, "power"] <- round(power, 2)
  }
  
  # Adjust p-values using Benjamini-Hochberg method for multiple testing of related tasks
  p_values_adjusted <- p.adjust(p_values_raw, method = "BH")
  df$p_value_adjusted <- round(p_values_adjusted, 2)
  
  return(df)
}

t_test_table <- t_test_mult_cols(df_basis = Patients_vs_HC_imp, cols = imp_columns)
#pander(t_test_table, style = "rmarkdown", fontsize = "tiny")
t_test_table
```

##  Table: Inferential Statistics
```{r}
# Create a data frame with inferential statistics (p-value, adjusted p-value, Cohen's d, power)
inferential_stats_df <- data.frame(
  Task = c("Number Letter Repeat", "Number Letter Switch", "Number Letter Difference BIS Score",
           "Stroop Congruent", "Stroop Incongruent", "Stroop BIS Difference Score",
           "Two Back Foil", "Two Back Target", "Two Back Difference BIS Score", "SSRT"),  # Include the missing task
  unadjusted_p_value = t_test_table$p_value,
  adjusted_p_value = t_test_table$p_value_adjusted,
  cohen_d = t_test_table$cohen_d,
  power = t_test_table$power
)

# Create the inferential statistics table using gt
inferential_stats_table <- inferential_stats_df %>%
  gt() %>% # uses gt instead of tbl_summary because easier implementation for inferential tables for which data already computed somewhere else
  tab_header(
    title = "Inferential Statistics: Healthy Controls vs. Patients"
  ) %>%
  cols_label(
    Task = html("<b>Task</b>"),
    unadjusted_p_value = html("<b>Unadjusted p-value</b>"),
    adjusted_p_value = html("<b>Adjusted p-value</b>"),
    cohen_d = html("<b>Cohen's d</b>"),
    power = html("<b>Power</b>")
  ) %>%
  fmt_number(
    columns = c(unadjusted_p_value, adjusted_p_value, cohen_d, power),
    decimals = 2
  )

inferential_stats_table
```

# Descriptive Statistics
Characteristics Table
Task-specific characteristics tables using tbl_summary
```{r}
# 1. Subset data frame by non-NA for respective tasks
task_list <- list(
  "Stroop Task" = list(
    subset_data = Patients_vs_HC %>%
      filter(!is.na(Stroop_BIS_Congruent) & 
             !is.na(Stroop_BIS_Incongruent) & 
             !is.na(Stroop_BIS_Diff_Score))
  ),
  "Number-Letter Task" = list(
    subset_data = Patients_vs_HC %>%
      filter(!is.na(NumberLetter_BIS_Repeat) & 
             !is.na(NumberLetter_BIS_Switch) & 
             !is.na(NumberLetter_BIS_Diff_Score))
  ),
  "2-Back Task" = list(
    subset_data = Patients_vs_HC %>%
      filter(!is.na(TwoBack_BIS_Foil) & 
             !is.na(TwoBack_BIS_Target) & 
             !is.na(TwoBack_BIS_Total))
  ),
  "Stop Signal Task" = list(
    subset_data = Patients_vs_HC %>%
      filter(!is.na(SSRT))
  )
)
```

```{r}
# 2. Function to generate characteristics table
generate_characteristics_table <- function(data, task_name) {
  data %>%
    select(Gruppe, Alter, Geschlecht, Abschluss, 
           T1_BAT_BDI_II_score, T1_BAT_BIS_11_score, T1_BAT_CFC_14_score, 
           T1_BAT_FAS_score, T1_BAT_Kirby_k_score, T1_BAT_SRHI_score, T1_BAT_STAI_T_score) %>%
    mutate(Gruppe = factor(Gruppe, levels = c(0, 1), labels = c("Healthy Controls", "Patients")),
           Geschlecht = factor(Geschlecht, levels = c(0, 1), labels = c("Male", "Female")),
           Abschluss = factor(Abschluss, levels = c(1, 2, 3, 4), 
                              labels = c("Basic secondary education", 
                                         "Intermediate secondary education",
                                         "Higher secondary education", 
                                         "Other"))) %>%
    tbl_summary(by = Gruppe,  # Compare by Gruppe (HC vs. Pat)
                label = list(
                  Alter ~ "Age",
                  Geschlecht ~ "Sex",
                  Abschluss ~ "Education",
                  T1_BAT_BDI_II_score ~ "BDI-II Score",
                  T1_BAT_BIS_11_score ~ "BIS-11 Score",
                  T1_BAT_CFC_14_score ~ "CFC-14 Score",
                  T1_BAT_FAS_score ~ "FSQ Score",
                  T1_BAT_Kirby_k_score ~ "Kirby k Score",
                  T1_BAT_SRHI_score ~ "SRHI Score",
                  T1_BAT_STAI_T_score ~ "STAI-T Score"
                ),
      statistic = list(
        all_continuous() ~ "{mean} ({sd})",
        all_categorical() ~ "{n} ({p}%)"
      ),
      missing = "no"
    ) %>%
    modify_header(label ~ "**Characteristic**") %>%
    modify_spanning_header(
      starts_with("T1_BAT_") ~ "**Baseline Assessment**"
    ) %>%
    # Remove the row for "Male" in sex
    modify_table_body(
      ~ .x %>% filter(!(variable == "Geschlecht" & label == "Male"))
    )
}

# Loop through the tasks and create tables
characteristics_tables <- lapply(names(task_list), function(task_name) {
  data <- task_list[[task_name]]$subset_data
  generate_characteristics_table(data, task_name)
})

# Name the tables for easy reference
names(characteristics_tables) <- names(task_list)
```

Combined data frame of task-specific descriptive characteristics
```{r}
# Calculate N for Healthy Controls and Patients for each task
calculate_n <- function(data) {
  data %>%
    group_by(Gruppe) %>%
    summarize(N = n(), .groups = "drop") %>%
    pivot_wider(names_from = Gruppe, values_from = N, names_prefix = "Group_") %>%
    rename("Healthy Controls" = Group_0, "Patients" = Group_1)
}

# Get N for each task
stroop_n <- calculate_n(task_list[["Stroop Task"]]$subset_data)
number_letter_n <- calculate_n(task_list[["Number-Letter Task"]]$subset_data)
two_back_n <- calculate_n(task_list[["2-Back Task"]]$subset_data)
ssrt_n <- calculate_n(task_list[["Stop Signal Task"]]$subset_data)

# Convert the tbl_summary tables to tibbles and rename columns dynamically (no information on specific N needed)
stroop_df <- as_tibble(characteristics_tables[["Stroop Task"]]) %>%
  rename_with(~ c("Healthy Controls", "Patients"), .cols = 2:3)

number_letter_df <- as_tibble(characteristics_tables[["Number-Letter Task"]]) %>%
  rename_with(~ c("Healthy Controls", "Patients"), .cols = 2:3)

two_back_df <- as_tibble(characteristics_tables[["2-Back Task"]]) %>%
  rename_with(~ c("Healthy Controls", "Patients"), .cols = 2:3)

ssrt_df <- as_tibble(characteristics_tables[["Stop Signal Task"]]) %>%
  rename_with(~ c("Healthy Controls", "Patients"), .cols = 2:3)

# Insert the "N" row into each data frame
stroop_df <- rbind(
  tibble("**Characteristic**" = "N", 
         "Healthy Controls" = stroop_n[["Healthy Controls"]], 
         "Patients" = stroop_n[["Patients"]]),
  stroop_df
)
number_letter_df <- rbind(
  tibble("**Characteristic**" = "N", 
         "Healthy Controls" = number_letter_n[["Healthy Controls"]], 
         "Patients" = number_letter_n[["Patients"]]),
  number_letter_df
)
two_back_df <- rbind(
  tibble("**Characteristic**" = "N", 
         "Healthy Controls" = two_back_n[["Healthy Controls"]], 
         "Patients" = two_back_n[["Patients"]]),
  two_back_df
)
ssrt_df <- rbind(
  tibble("**Characteristic**" = "N", 
         "Healthy Controls" = ssrt_n[["Healthy Controls"]], 
         "Patients" = ssrt_n[["Patients"]]),
  ssrt_df
)

# Combine the modified data frames
characteristics_tasks <- cbind(
  stroop_df[, "**Characteristic**", drop = FALSE],  # Include "Characteristic" column only once
  stroop_df[, -which(names(stroop_df) == "**Characteristic**")],
  number_letter_df[, -which(names(number_letter_df) == "**Characteristic**")],
  two_back_df[, -which(names(two_back_df) == "**Characteristic**")],
  ssrt_df[, -which(names(ssrt_df) == "**Characteristic**")]  # Drop "Characteristic" column from all others
)
```

Flextable
```{r, echo = FALSE}
# Specify Settings
# Flextable
set_flextable_defaults(font.family = "Arial",
font.size = 8,
padding.bottom = 3,
padding.top = 3,
padding.left = 0.5,
paddings.right = 0.5,
#theme_fun = "theme_apa",
theme_fun = NULL,
text.align = "center",
line_spacing = 1.5)

# Word documents to save flextables
margins <- page_mar(
  bottom = 0.5,
  top = 0.5,
  right = 0.5,
  left = 0.5,
  header = 0.5,
  footer = 0.5,
  gutter = 0.5
)

format_table_wide <- prop_section(
  page_size = page_size(orient = "landscape"),
  page_margins = margins)
```

```{r}
# Create Flextable
# Rename columns to ensure uniqueness
colnames(characteristics_tasks) <- c(
  "Characteristic", 
  "Stroop_Healthy_Controls", "Stroop_Patients", 
  "Number_Letter_Healthy_Controls", "Number_Letter_Patients", 
  "Two_Back_Healthy_Controls", "Two_Back_Patients", 
  "Stop_Signal_Healthy_Controls", "Stop_Signal_Patients"
)

# Define primary (task) and secondary (HC vs Pat) headers
primary_headers <- c("Characteristic", "Stroop Task", "Stroop Task", 
                     "Number-Letter Task", "Number-Letter Task", 
                     "2-Back Task", "2-Back Task", 
                     "Stop Signal Task", "Stop Signal Task")

secondary_headers <- c("Characteristic", "Healthy Controls", "Patients", 
                       "Healthy Controls", "Patients", 
                       "Healthy Controls", "Patients", 
                       "Healthy Controls", "Patients")

# Create a flextable
ft <- flextable(characteristics_tasks)

# Add primary and secondary column headers
ft <- set_header_df(
  x = ft,
  mapping = data.frame(
    keys = colnames(characteristics_tasks),
    primary = primary_headers,
    secondary = secondary_headers,
    stringsAsFactors = FALSE
  ),
  key = "keys"
)

# Merge the primary headers to span across related columns
ft <- merge_h(ft, part = "header")

# Align and format the headers
ft <- align(ft, align = "center", part = "header")
ft <- bold(ft, part = "header")
ft <- autofit(ft)

# Write to Word
save_as_docx(ft, path="Characteristics Table.docx", pr_section = format_table_wide)
```


```{r}
leveneTest(T1_BAT_STAI_T_score ~ as.factor(Gruppe), data = Patients_vs_HC)
t_test_result <- t.test(T1_BAT_STAI_T_score ~ Gruppe, data = Patients_vs_HC, var.equal = FALSE)
print(t_test_result)
```

## Differences in trait anxiety - significant?
```{r}
car::leveneTest(T1_BAT_STAI_T_score ~ as.factor(Gruppe), data = Patients_vs_HC)
t_test_result <- t.test(T1_BAT_STAI_T_score ~ Gruppe, data = Patients_vs_HC, var.equal = FALSE)
print(t_test_result)
```

## Explorative analysis: trait anxiety?
```{r}
ggplot(Patients_vs_HC, aes(x = Gruppe, y = T1_BAT_STAI_T_score, color = Gruppe)) +
  geom_boxplot(outlier.shape = NA, alpha = 0.6) +  # Boxplot to show group distribution
  geom_jitter(width = 0.2, size = 2, alpha = 0.7) + # Add points for individual values
  labs(
    title = "T1 BAT STAI T Score by Group",
    x = "Group (Gruppe)",
    y = "T1 BAT STAI T Score"
  )

t_test_mult_cols <- function(df_basis, cols, split_col) {
  # Perform a t-test for multiple variables after splitting based on the median of `split_col`
  
  # Perform median split on the specified column (split_col)
  median_value <- median(df_basis[[split_col]], na.rm = TRUE)
  df_basis$Anxiety_Group <- ifelse(df_basis[[split_col]] > median_value, "High", "Low")
  
  # Create a dataframe to store results
  df <- data.frame(
    t_statistic = numeric(length(cols)), 
    p_value = numeric(length(cols)),
    group_mean_High = numeric(length(cols)), 
    sd_High = numeric(length(cols)),
    group_mean_Low = numeric(length(cols)), 
    sd_Low = numeric(length(cols)),
    cohen_d = numeric(length(cols)), 
    power = numeric(length(cols))
  )
  rownames(df) <- cols
  p_values_raw <- numeric(length(cols))  # Store raw p-values
  
  for (i in seq_along(cols)) {
    col <- cols[i]  # Current column
    
    # Split the data into high and low anxiety groups
    group_high <- na.omit(df_basis[df_basis$Anxiety_Group == "High", col])
    group_low <- na.omit(df_basis[df_basis$Anxiety_Group == "Low", col])
    
    # Perform t-test
    results <- t.test(group_high, group_low, paired = FALSE, var.equal = FALSE)
    p_values_raw[i] <- results$p.value  # Store raw p-value
    
    # Calculate Cohen's d
    cohen_d_result <- cohen.d(group_high, group_low, hedges.correction = FALSE)
    cohen_d <- cohen_d_result$estimate
    
    # Calculate power
    n_high <- length(group_high)
    n_low <- length(group_low)
    power_result <- pwr.t.test(d = cohen_d, n = min(n_high, n_low), sig.level = 0.05, type = "two.sample", alternative = "greater")
    power <- power_result$power
    
    # Store the results
    df[col, "t_statistic"] <- round(results$statistic, 2)
    df[col, "p_value"] <- round(results$p.value, 2)
    df[col, "group_mean_High"] <- round(mean(group_high), 2)
    df[col, "sd_High"] <- round(sd(group_high), 2)
    df[col, "group_mean_Low"] <- round(mean(group_low), 2)
    df[col, "sd_Low"] <- round(sd(group_low), 2)
    df[col, "cohen_d"] <- round(cohen_d, 2)
    df[col, "power"] <- round(power, 2)
  }
  
  # Adjust p-values using the Benjamini-Hochberg method
  p_values_adjusted <- p.adjust(p_values_raw, method = "BH")
  df$p_value_adjusted <- round(p_values_adjusted, 2)
  
  return(df)
}

t_test_mult_cols(df_basis = Patients_vs_HC[Patients_vs_HC$Gruppe == 0,], cols = imp_columns, split_col = "T1_BAT_STAI_T_score")
```

## Plotting

### Prepare data
```{r}
# Reshape data from wide to long format, including SSRT
Patients_vs_HC_long <- Patients_vs_HC_imp %>%
  pivot_longer(cols = all_of(imp_columns), # imp_columns now includes SSRT
               names_to = "Condition",
               values_to = "BIS_Score")

# Add new task variable to keep the headers intact for faceting
Patients_vs_HC_long <- Patients_vs_HC_long %>%
  mutate(Task = case_when(
    grepl("NumberLetter", Condition) ~ "Number-Letter Task",
    grepl("Stroop", Condition) ~ "Stroop Task",
    grepl("TwoBack", Condition) ~ "2-Back Task",
    Condition == "SSRT" ~ "Stop Signal Task"
  ))

# Remove prefixes from Condition labels, keeping Task intact
Patients_vs_HC_long <- Patients_vs_HC_long %>%
  mutate(Condition = gsub("NumberLetter_BIS_|Stroop_BIS_|TwoBack_BIS_", "", Condition)) %>%
  mutate(Condition = as.character(Condition)) %>%
  
  # Set the condition order for each task separately to avoid conflicts (cannot both be "Diff_Score")
  mutate(Condition = ifelse(Task == "NumberLetter" & Condition == "Diff_Score", "Diff_Score NL", Condition)) %>%
  mutate(Condition = ifelse(Task == "Stroop" & Condition == "Diff_Score", "Diff_Score Stroop", Condition)) %>%
  
  # Convert Condition to factor with ordering
  mutate(Condition = case_when(
    Task == "NumberLetter" ~ factor(Condition, levels = c("Repeat", "Switch", "Diff_Score NL")),
    Task == "Stroop" ~ factor(Condition, levels = c("Congruent", "Incongruent", "Diff_Score Stroop")),
    Task == "TwoBack" ~ factor(Condition, levels = c("Foil", "Target", "Total")),
    TRUE ~ as.factor(Condition)
  ))

# Convert "Gruppe" to factor
Patients_vs_HC_long$Gruppe <- factor(Patients_vs_HC_long$Gruppe, levels = c(0, 1), labels = c("Healthy Controls", "Patients"))
```

### Violin Plot: Patients vs. Healthy Controls
```{r, fig.width = 16, fig.height = 9}
# Create violin plots with mean and rename conditions in the plot

violin_plots_patients_hc <- ggplot(Patients_vs_HC_long, aes(x = Condition, y = BIS_Score, fill = Gruppe)) +
  geom_violin(position = position_dodge(width = 0.8)) +
  stat_summary(fun.data = mean_sdl, geom = "pointrange", # mult = 2 (SD) by default
               position = position_dodge(width = 0.8)) + # width = 0.65, fatten = 2
  facet_wrap(~ Task, scales = "free") +
  labs(x = "",
       y = "Performance Score",
       fill = "Group") +
  scale_x_discrete(labels = function(x) {
    x[x == "Diff_Score"] <- "Difference \nScore"
    x[x == "Diff_Score Stroop"] <- "Difference \nScore"
    x[x == "Total"] <- "Difference \nScore"
    return(x)
  }) +
  scale_fill_manual(values = c("Healthy Controls" = "#D3D3D3", #colors 
                                 "Patients" = "#48CFCB")) +
  theme_bw() +
  theme(
    text = element_text(family = "Arial"), #Font
    axis.title = element_text(size = 24),
    axis.title.y = element_text(size = 24, margin = margin(r = 30)),
    axis.text = element_text(size = 18),
    legend.title = element_text(size = 24),
    legend.text = element_text(size = 18),
    strip.text = element_text(size = 20),
    panel.spacing.x = unit(3, "lines")
  )
print(violin_plots_patients_hc)
ggsave("violin_plots_patients_hc.png", plot = violin_plots_patients_hc, width = 16, height = 9, dpi = 300)
```

### Boxplot: Patients vs. Healthy Controls
```{r}
# Create boxplots
boxplots_Patients_HC <- ggplot(Patients_vs_HC_long, aes(x = Condition, y = BIS_Score, color = Gruppe)) +
  geom_boxplot(outlier.shape = NA) + 
  geom_jitter(position = position_jitterdodge(),
              size = 0.7,
              shape = 21,
              fill = NA) +
  facet_wrap(~ Task, scales = "free") +
  #facet_grid(rows = vars(Task), scales = "free_x") +
  labs(title = "Boxplots of Task Condition by Group",
       x = "Condition",
       y = "BIS-Score",
       color = "Group")
print(boxplots_Patients_HC)
```
